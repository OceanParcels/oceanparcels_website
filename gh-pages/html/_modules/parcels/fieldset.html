

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>parcels.fieldset &#8212; Parcels  documentation</title>
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-96368922-1', 'auto');
  ga('send', 'pageview');
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Parcels  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/parcelslogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for parcels.fieldset</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>

<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">parcels.field</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">DeferredArray</span>
<span class="kn">from</span> <span class="nn">parcels.field</span> <span class="kn">import</span> <span class="n">NestedField</span>
<span class="kn">from</span> <span class="nn">parcels.field</span> <span class="kn">import</span> <span class="n">SummedField</span>
<span class="kn">from</span> <span class="nn">parcels.field</span> <span class="kn">import</span> <span class="n">VectorField</span>
<span class="kn">from</span> <span class="nn">parcels.grid</span> <span class="kn">import</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">parcels.gridset</span> <span class="kn">import</span> <span class="n">GridSet</span>
<span class="kn">from</span> <span class="nn">parcels.tools.converters</span> <span class="kn">import</span> <span class="n">TimeConverter</span><span class="p">,</span> <span class="n">convert_xarray_time_units</span>
<span class="kn">from</span> <span class="nn">parcels.tools.error</span> <span class="kn">import</span> <span class="n">TimeExtrapolationError</span>
<span class="kn">from</span> <span class="nn">parcels.tools.loggers</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">MPI</span> <span class="o">=</span> <span class="kc">None</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FieldSet&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="FieldSet"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet">[docs]</a><span class="k">class</span> <span class="nc">FieldSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;FieldSet class that holds hydrodynamic data needed to execute particles</span>

<span class="sd">    :param U: :class:`parcels.field.Field` object for zonal velocity component</span>
<span class="sd">    :param V: :class:`parcels.field.Field` object for meridional velocity component</span>
<span class="sd">    :param fields: Dictionary of additional :class:`parcels.field.Field` objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridset</span> <span class="o">=</span> <span class="n">GridSet</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">U</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time_origin</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">Field</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time_origin</span>
        <span class="k">if</span> <span class="n">V</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span>

        <span class="c1"># Add additional fields as attributes</span>
        <span class="k">if</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_on_defer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">checkvaliddimensionsdict</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid key in the dimensions dictionary&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>

<div class="viewcode-block" id="FieldSet.from_data"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_data">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span>
                  <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise FieldSet object from raw data</span>

<span class="sd">        :param data: Dictionary mapping field names to numpy arrays.</span>
<span class="sd">               Note that at least a &#39;U&#39; and &#39;V&#39; numpy array need to be given, and that</span>
<span class="sd">               the built-in Advection kernels assume that U and V are in m/s</span>

<span class="sd">               1. If data shape is [xdim, ydim], [xdim, ydim, zdim], [xdim, ydim, tdim] or [xdim, ydim, zdim, tdim],</span>
<span class="sd">                  whichever is relevant for the dataset, use the flag transpose=True</span>
<span class="sd">               2. If data shape is [ydim, xdim], [zdim, ydim, xdim], [tdim, ydim, xdim] or [tdim, zdim, ydim, xdim],</span>
<span class="sd">                  use the flag transpose=False (default value)</span>
<span class="sd">               3. If data has any other shape, you first need to reorder it</span>
<span class="sd">        :param dimensions: Dictionary mapping field dimensions (lon,</span>
<span class="sd">               lat, depth, time) to numpy arrays.</span>
<span class="sd">               Note that dimensions can also be a dictionary of dictionaries if</span>
<span class="sd">               dimension names are different for each variable</span>
<span class="sd">               (e.g. dimensions[&#39;U&#39;], dimensions[&#39;V&#39;], etc).</span>
<span class="sd">        :param transpose: Boolean whether to transpose data on read-in</span>
<span class="sd">        :param mesh: String indicating the type of mesh coordinates and</span>
<span class="sd">               units used during velocity interpolation, see also https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb:</span>

<span class="sd">               1. spherical (default): Lat and lon in degree, with a</span>
<span class="sd">                  correction for zonal velocity U near the poles.</span>
<span class="sd">               2. flat: No conversion, lat/lon are assumed to be in m.</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">datafld</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Use dimensions[name] if dimensions is a dict of dicts</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">else</span> <span class="n">dimensions</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">checkvaliddimensionsdict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">allow_time_extrapolation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">allow_time_extrapolation</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="kc">True</span>

            <span class="n">lon</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;depth&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="n">dims</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="n">dims</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">time</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
                <span class="n">time_origin</span> <span class="o">=</span> <span class="n">TimeConverter</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">time_origin</span><span class="o">.</span><span class="n">reltime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_origin</span> <span class="o">=</span> <span class="n">TimeConverter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">create_grid</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">time_origin</span><span class="o">=</span><span class="n">time_origin</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_data&#39;</span>

            <span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">datafld</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="n">transpose</span><span class="p">,</span>
                                 <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.add_field"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.add_field">[docs]</a>    <span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a :class:`parcels.field.Field` object to the FieldSet</span>

<span class="sd">        :param field: :class:`parcels.field.Field` object to be added</span>
<span class="sd">        :param name: Name of the :class:`parcels.field.Field` object to be added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>  <span class="c1"># check if Field with same name already exists when adding new Field</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;FieldSet already has a Field with name &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gridset</span><span class="o">.</span><span class="n">add_grid</span><span class="p">(</span><span class="n">fld</span><span class="p">)</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">fieldset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gridset</span><span class="o">.</span><span class="n">add_grid</span><span class="p">(</span><span class="n">fld</span><span class="p">)</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">fieldset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;FieldLists have been replaced by SummedFields. Use the + operator instead of []&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">DeferredArray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Array</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># ==== check for inhabiting the same grid, and homogenise the grid chunking ==== #</span>
                <span class="n">g_set</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">grid</span>
                <span class="n">grid_chunksize</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">field_chunksize</span>
                <span class="n">dFiles</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">dataFiles</span>
                <span class="n">is_processed_grid</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">is_same_grid</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>       <span class="c1"># avoid re-processing/overwriting existing and working fields</span>
                    <span class="k">if</span> <span class="n">fld</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="n">g_set</span><span class="p">:</span>
                        <span class="n">is_processed_grid</span> <span class="o">|=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_processed_grid</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
                        <span class="n">procdims</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">dimensions</span>
                        <span class="n">procinds</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">indices</span>
                        <span class="n">procpaths</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">dataFiles</span>
                        <span class="n">nowpaths</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">dataFiles</span>
                        <span class="k">if</span> <span class="n">procdims</span> <span class="o">==</span> <span class="n">field</span><span class="o">.</span><span class="n">dimensions</span> <span class="ow">and</span> <span class="n">procinds</span> <span class="o">==</span> <span class="n">field</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                            <span class="n">is_same_grid</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">mesh</span> <span class="o">==</span> <span class="n">fld</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
                                <span class="n">is_same_grid</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">is_same_grid</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]:</span>
                                    <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">fld</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                        <span class="n">is_same_grid</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">fld</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                                <span class="n">fld_g_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">fld</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">tdim</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">zdim</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">ydim</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">xdim</span><span class="p">]</span>
                                <span class="n">field_g_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">tdim</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">zdim</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ydim</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">xdim</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fld_g_dims</span><span class="p">)):</span>
                                    <span class="n">is_same_grid</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">field_g_dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">fld_g_dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">is_same_grid</span><span class="p">:</span>
                                <span class="n">g_set</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">grid</span>
                                <span class="c1"># ==== check here that the dims of field_chunksize are the same ==== #</span>
                                <span class="k">if</span> <span class="n">g_set</span><span class="o">.</span><span class="n">master_chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">res</span> <span class="o">=</span> <span class="kc">False</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g_set</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g_set</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                                        <span class="n">res</span> <span class="o">|=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">m</span> <span class="o">==</span> <span class="n">k</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="n">g_set</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">res</span> <span class="o">|=</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">field_chunksize</span> <span class="o">==</span> <span class="n">g_set</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                                        <span class="n">grid_chunksize</span> <span class="o">=</span> <span class="n">g_set</span><span class="o">.</span><span class="n">master_chunksize</span>
                                        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">master_chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                            <span class="n">logger</span><span class="o">.</span><span class="n">warning_once</span><span class="p">(</span><span class="s2">&quot;Trying to initialize a shared grid with different chunking sizes - action prohibited. Replacing requested field_chunksize with grid&#39;s master chunksize.&quot;</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Conflict between grids of the same fieldset chunksize and requested field chunksize as well as the chunked name dimensions - Please apply the same chunksize to all fields in a shared grid!&quot;</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">procpaths</span> <span class="o">==</span> <span class="n">nowpaths</span><span class="p">:</span>
                                    <span class="n">dFiles</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">dataFiles</span>
                                    <span class="k">break</span>
                    <span class="k">if</span> <span class="n">is_same_grid</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">grid</span> <span class="o">!=</span> <span class="n">g_set</span><span class="p">:</span>
                            <span class="n">field</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">g_set</span>
                        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">field_chunksize</span> <span class="o">!=</span> <span class="n">grid_chunksize</span><span class="p">:</span>
                            <span class="n">field</span><span class="o">.</span><span class="n">field_chunksize</span> <span class="o">=</span> <span class="n">grid_chunksize</span>
                        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">dataFiles</span> <span class="o">!=</span> <span class="n">dFiles</span><span class="p">:</span>
                            <span class="n">field</span><span class="o">.</span><span class="n">dataFiles</span> <span class="o">=</span> <span class="n">dFiles</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">gridset</span><span class="o">.</span><span class="n">add_grid</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

            <span class="n">field</span><span class="o">.</span><span class="n">fieldset</span> <span class="o">=</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="FieldSet.add_vector_field"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.add_vector_field">[docs]</a>    <span class="k">def</span> <span class="nf">add_vector_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vfield</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a :class:`parcels.field.VectorField` object to the FieldSet</span>

<span class="sd">        :param vfield: :class:`parcels.field.VectorField` object to be added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vfield</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">vfield</span><span class="p">)</span>
        <span class="n">vfield</span><span class="o">.</span><span class="n">fieldset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfield</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">vfield</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">fieldset</span> <span class="o">=</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">check_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="s1">&#39;FieldSet does not have a Field named &quot;U&quot;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="s1">&#39;FieldSet does not have a Field named &quot;V&quot;&#39;</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Field</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">attr</span><span class="p">,</span> <span class="s1">&#39;Field </span><span class="si">%s</span><span class="s1">.name (</span><span class="si">%s</span><span class="s1">) is not consistent&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridset</span><span class="o">.</span><span class="n">grids</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">check_zonal_periodic</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">time_origin</span><span class="o">.</span><span class="n">time_origin</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_origin</span><span class="o">.</span><span class="n">time_origin</span><span class="p">)),</span> <span class="s1">&#39;time origins of different grids must be have the same type&#39;</span>
            <span class="n">g</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_origin</span><span class="o">.</span><span class="n">reltime</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">time_origin</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">defer_load</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">time_full</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">time_full</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_origin</span><span class="o">.</span><span class="n">reltime</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">time_origin</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">time_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_origin</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;UV&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vector_field</span><span class="p">(</span><span class="n">SummedField</span><span class="p">(</span><span class="s1">&#39;UV&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vector_field</span><span class="p">(</span><span class="n">NestedField</span><span class="p">(</span><span class="s1">&#39;UV&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vector_field</span><span class="p">(</span><span class="n">VectorField</span><span class="p">(</span><span class="s1">&#39;UV&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;UVW&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vector_field</span><span class="p">(</span><span class="n">SummedField</span><span class="p">(</span><span class="s1">&#39;UVW&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vector_field</span><span class="p">(</span><span class="n">NestedField</span><span class="p">(</span><span class="s1">&#39;UVW&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vector_field</span><span class="p">(</span><span class="n">VectorField</span><span class="p">(</span><span class="s1">&#39;UVW&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">))</span>

        <span class="n">ccode_fieldnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">fld</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ccode_fieldnames</span><span class="p">:</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">ccode_name</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">ccode_name</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ccode_fieldnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">ccode_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">VectorField</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">]</span> <span class="ow">or</span> <span class="n">f</span><span class="o">.</span><span class="n">dataFiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">depth_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">depth_field</span> <span class="o">==</span> <span class="s1">&#39;not_yet_set&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If depth dimension is set at &#39;not_yet_set&#39;, it must be added later using Field.set_depth_from_field(field)&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">defer_load</span><span class="p">:</span>
                    <span class="n">depth_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">depth_field</span><span class="o">.</span><span class="n">data</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth_data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">depth_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">depth_data</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_wildcards</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">paths</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">notfound_paths</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">filenames</span> <span class="k">else</span> <span class="n">filenames</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;FieldSet files not found: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">notfound_paths</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;FieldSet file not found: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">paths</span>

<div class="viewcode-block" id="FieldSet.from_netcdf"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_netcdf">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_netcdf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fieldtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span> <span class="n">timestamps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">deferred_load</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">field_chunksize</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises FieldSet object from NetCDF files</span>

<span class="sd">        :param filenames: Dictionary mapping variables to file(s). The</span>
<span class="sd">               filepath may contain wildcards to indicate multiple files</span>
<span class="sd">               or be a list of file.</span>
<span class="sd">               filenames can be a list [files], a dictionary {var:[files]},</span>
<span class="sd">               a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),</span>
<span class="sd">               or a dictionary of dictionaries {var:{dim:[files]}}.</span>
<span class="sd">               time values are in filenames[data]</span>
<span class="sd">        :param variables: Dictionary mapping variables to variable names in the netCDF file(s).</span>
<span class="sd">               Note that the built-in Advection kernels assume that U and V are in m/s</span>
<span class="sd">        :param dimensions: Dictionary mapping data dimensions (lon,</span>
<span class="sd">               lat, depth, time, data) to dimensions in the netCF file(s).</span>
<span class="sd">               Note that dimensions can also be a dictionary of dictionaries if</span>
<span class="sd">               dimension names are different for each variable</span>
<span class="sd">               (e.g. dimensions[&#39;U&#39;], dimensions[&#39;V&#39;], etc).</span>
<span class="sd">        :param indices: Optional dictionary of indices for each dimension</span>
<span class="sd">               to read from file(s), to allow for reading of subset of data.</span>
<span class="sd">               Default is to read the full extent of each dimension.</span>
<span class="sd">               Note that negative indices are not allowed.</span>
<span class="sd">        :param fieldtype: Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.</span>
<span class="sd">               (either &#39;U&#39;, &#39;V&#39;, &#39;Kh_zonal&#39;, &#39;Kh_meridional&#39; or None)</span>
<span class="sd">        :param mesh: String indicating the type of mesh coordinates and</span>
<span class="sd">               units used during velocity interpolation, see also https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb:</span>

<span class="sd">               1. spherical (default): Lat and lon in degree, with a</span>
<span class="sd">                  correction for zonal velocity U near the poles.</span>
<span class="sd">               2. flat: No conversion, lat/lon are assumed to be in m.</span>
<span class="sd">        :param timestamps: list of lists or array of arrays containing the timestamps for</span>
<span class="sd">               each of the files in filenames. Outer list/array corresponds to files, inner</span>
<span class="sd">               array corresponds to indices within files.</span>
<span class="sd">               Default is None if dimensions includes time.</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        :param deferred_load: boolean whether to only pre-load data (in deferred mode) or</span>
<span class="sd">               fully load them (default: True). It is advised to deferred load the data, since in</span>
<span class="sd">               that case Parcels deals with a better memory management during particle set execution.</span>
<span class="sd">               deferred_load=False is however sometimes necessary for plotting the fields.</span>
<span class="sd">        :param field_chunksize: size of the chunks in dask loading</span>
<span class="sd">        :param netcdf_engine: engine to use for netcdf reading in xarray. Default is &#39;netcdf&#39;,</span>
<span class="sd">               but in cases where this doesn&#39;t work, setting netcdf_engine=&#39;scipy&#39; could help</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that times are not provided both in netcdf file and in &#39;timestamps&#39;.</span>
        <span class="k">if</span> <span class="n">timestamps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning_once</span><span class="p">(</span><span class="s2">&quot;Time already provided, defaulting to dimensions[&#39;time&#39;] over timestamps.&quot;</span><span class="p">)</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_netcdf&#39;</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Resolve all matching paths for the current variable</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">filenames</span> <span class="k">else</span> <span class="n">filenames</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">paths</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">parse_wildcards</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">parse_wildcards</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

            <span class="c1"># Use dimensions[var] and indices[var] if either of them is a dict of dicts</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">else</span> <span class="n">dimensions</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">checkvaliddimensionsdict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span> <span class="k">else</span> <span class="n">indices</span>
            <span class="n">fieldtype</span> <span class="o">=</span> <span class="n">fieldtype</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">fieldtype</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fieldtype</span><span class="p">)</span> <span class="k">else</span> <span class="n">fieldtype</span>
            <span class="n">chunksize</span> <span class="o">=</span> <span class="n">field_chunksize</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">field_chunksize</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">field_chunksize</span><span class="p">)</span> <span class="k">else</span> <span class="n">field_chunksize</span>

            <span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">grid_chunksize</span> <span class="o">=</span> <span class="n">chunksize</span>
            <span class="n">dFiles</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># check if grid has already been processed (i.e. if other fields have same filenames, dimensions and indices)</span>
            <span class="k">for</span> <span class="n">procvar</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">procdims</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">procvar</span><span class="p">]</span> <span class="k">if</span> <span class="n">procvar</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">else</span> <span class="n">dimensions</span>
                <span class="n">procinds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">procvar</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="ow">and</span> <span class="n">procvar</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span> <span class="k">else</span> <span class="n">indices</span>
                <span class="n">procpaths</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">[</span><span class="n">procvar</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">procvar</span> <span class="ow">in</span> <span class="n">filenames</span> <span class="k">else</span> <span class="n">filenames</span>
                <span class="n">nowpaths</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">filenames</span> <span class="k">else</span> <span class="n">filenames</span>
                <span class="k">if</span> <span class="n">procdims</span> <span class="o">==</span> <span class="n">dims</span> <span class="ow">and</span> <span class="n">procinds</span> <span class="o">==</span> <span class="n">inds</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;depth&#39;</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">and</span> <span class="n">dims</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;not_yet_set&#39;</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">processedGrid</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span> <span class="ow">or</span> <span class="n">filenames</span><span class="p">[</span><span class="n">procvar</span><span class="p">]</span> <span class="o">==</span> <span class="n">filenames</span><span class="p">[</span><span class="n">var</span><span class="p">]):</span>
                        <span class="n">processedGrid</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">procvar</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">processedGrid</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
                                <span class="n">processedGrid</span> <span class="o">*=</span> <span class="n">filenames</span><span class="p">[</span><span class="n">procvar</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">filenames</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">processedGrid</span><span class="p">:</span>
                        <span class="n">grid</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="n">procvar</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span>
                        <span class="c1"># ==== check here that the dims of field_chunksize are the same ==== #</span>
                        <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">master_chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">res</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">chunksize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">chunksize</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                                <span class="n">res</span> <span class="o">|=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">m</span> <span class="o">==</span> <span class="n">k</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">res</span> <span class="o">|=</span> <span class="p">(</span><span class="n">chunksize</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">master_chunksize</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                                <span class="n">grid_chunksize</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">master_chunksize</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">warning_once</span><span class="p">(</span><span class="s2">&quot;Trying to initialize a shared grid with different chunking sizes - action prohibited. Replacing requested field_chunksize with grid&#39;s master chunksize.&quot;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Conflict between grids of the same fieldset chunksize and requested field chunksize as well as the chunked name dimensions - Please apply the same chunksize to all fields in a shared grid!&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">procpaths</span> <span class="o">==</span> <span class="n">nowpaths</span><span class="p">:</span>
                            <span class="n">dFiles</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="n">procvar</span><span class="p">]</span><span class="o">.</span><span class="n">dataFiles</span>
                            <span class="k">break</span>
            <span class="n">fields</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="o">.</span><span class="n">from_netcdf</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">dims</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">timestamps</span><span class="o">=</span><span class="n">timestamps</span><span class="p">,</span>
                                            <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span>
                                            <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span> <span class="n">deferred_load</span><span class="o">=</span><span class="n">deferred_load</span><span class="p">,</span>
                                            <span class="n">fieldtype</span><span class="o">=</span><span class="n">fieldtype</span><span class="p">,</span> <span class="n">field_chunksize</span><span class="o">=</span><span class="n">grid_chunksize</span><span class="p">,</span> <span class="n">dataFiles</span><span class="o">=</span><span class="n">dFiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.from_nemo"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_nemo">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_nemo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span>
                  <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">tracer_interp_method</span><span class="o">=</span><span class="s1">&#39;cgrid_tracer&#39;</span><span class="p">,</span> <span class="n">field_chunksize</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises FieldSet object from NetCDF files of Curvilinear NEMO fields.</span>

<span class="sd">        :param filenames: Dictionary mapping variables to file(s). The</span>
<span class="sd">               filepath may contain wildcards to indicate multiple files,</span>
<span class="sd">               or be a list of file.</span>
<span class="sd">               filenames can be a list [files], a dictionary {var:[files]},</span>
<span class="sd">               a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),</span>
<span class="sd">               or a dictionary of dictionaries {var:{dim:[files]}}</span>
<span class="sd">               time values are in filenames[data]</span>
<span class="sd">        :param variables: Dictionary mapping variables to variable names in the netCDF file(s).</span>
<span class="sd">               Note that the built-in Advection kernels assume that U and V are in m/s</span>
<span class="sd">        :param dimensions: Dictionary mapping data dimensions (lon,</span>
<span class="sd">               lat, depth, time, data) to dimensions in the netCF file(s).</span>
<span class="sd">               Note that dimensions can also be a dictionary of dictionaries if</span>
<span class="sd">               dimension names are different for each variable.</span>
<span class="sd">               Watch out: NEMO is discretised on a C-grid:</span>
<span class="sd">               U and V velocities are not located on the same nodes (see https://www.nemo-ocean.eu/doc/node19.html ).</span>
<span class="sd">                _________________V[k,j+1,i+1]________________</span>
<span class="sd">               |                                             |</span>
<span class="sd">               |                                             |</span>
<span class="sd">               U[k,j+1,i]   W[k:k+2,j+1,i+1], T[k,j+1,i+1]   U[k,j+1,i+1]</span>
<span class="sd">               |                                             |</span>
<span class="sd">               |                                             |</span>
<span class="sd">               |_________________V[k,j,i+1]__________________|</span>
<span class="sd">               To interpolate U, V velocities on the C-grid, Parcels needs to read the f-nodes,</span>
<span class="sd">               which are located on the corners of the cells.</span>
<span class="sd">               (for indexing details: https://www.nemo-ocean.eu/doc/img360.png )</span>
<span class="sd">               In 3D, the depth is the one corresponding to W nodes</span>
<span class="sd">        :param indices: Optional dictionary of indices for each dimension</span>
<span class="sd">               to read from file(s), to allow for reading of subset of data.</span>
<span class="sd">               Default is to read the full extent of each dimension.</span>
<span class="sd">               Note that negative indices are not allowed.</span>
<span class="sd">        :param fieldtype: Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.</span>
<span class="sd">               (either &#39;U&#39;, &#39;V&#39;, &#39;Kh_zonal&#39;, &#39;Kh_meridional&#39; or None)</span>
<span class="sd">        :param mesh: String indicating the type of mesh coordinates and</span>
<span class="sd">               units used during velocity interpolation, see also https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb:</span>

<span class="sd">               1. spherical (default): Lat and lon in degree, with a</span>
<span class="sd">                  correction for zonal velocity U near the poles.</span>
<span class="sd">               2. flat: No conversion, lat/lon are assumed to be in m.</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        :param tracer_interp_method: Method for interpolation of tracer fields. It is recommended to use &#39;cgrid_tracer&#39; (default)</span>
<span class="sd">               Note that in the case of from_nemo() and from_cgrid(), the velocity fields are default to &#39;cgrid_velocity&#39;</span>
<span class="sd">        :param field_chunksize: size of the chunks in dask loading</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_nemo&#39;</span>
        <span class="n">fieldset</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_c_grid_dataset</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span>
                                           <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span> <span class="n">tracer_interp_method</span><span class="o">=</span><span class="n">tracer_interp_method</span><span class="p">,</span>
                                           <span class="n">field_chunksize</span><span class="o">=</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fieldset</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">):</span>
            <span class="n">fieldset</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">set_scaling_factor</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fieldset</span></div>

<div class="viewcode-block" id="FieldSet.from_c_grid_dataset"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_c_grid_dataset">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_c_grid_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span>
                            <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">tracer_interp_method</span><span class="o">=</span><span class="s1">&#39;cgrid_tracer&#39;</span><span class="p">,</span> <span class="n">field_chunksize</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises FieldSet object from NetCDF files of Curvilinear NEMO fields.</span>

<span class="sd">        :param filenames: Dictionary mapping variables to file(s). The</span>
<span class="sd">               filepath may contain wildcards to indicate multiple files,</span>
<span class="sd">               or be a list of file.</span>
<span class="sd">               filenames can be a list [files], a dictionary {var:[files]},</span>
<span class="sd">               a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),</span>
<span class="sd">               or a dictionary of dictionaries {var:{dim:[files]}}</span>
<span class="sd">               time values are in filenames[data]</span>
<span class="sd">        :param variables: Dictionary mapping variables to variable</span>
<span class="sd">               names in the netCDF file(s).</span>
<span class="sd">        :param dimensions: Dictionary mapping data dimensions (lon,</span>
<span class="sd">               lat, depth, time, data) to dimensions in the netCF file(s).</span>
<span class="sd">               Note that dimensions can also be a dictionary of dictionaries if</span>
<span class="sd">               dimension names are different for each variable.</span>
<span class="sd">               Watch out: NEMO is discretised on a C-grid:</span>
<span class="sd">               U and V velocities are not located on the same nodes (see https://www.nemo-ocean.eu/doc/node19.html ).</span>
<span class="sd">                _________________V[k,j+1,i+1]________________</span>
<span class="sd">               |                                             |</span>
<span class="sd">               |                                             |</span>
<span class="sd">               U[k,j+1,i]   W[k:k+2,j+1,i+1], T[k,j+1,i+1]   U[k,j+1,i+1]</span>
<span class="sd">               |                                             |</span>
<span class="sd">               |                                             |</span>
<span class="sd">               |_________________V[k,j,i+1]__________________|</span>
<span class="sd">               To interpolate U, V velocities on the C-grid, Parcels needs to read the f-nodes,</span>
<span class="sd">               which are located on the corners of the cells.</span>
<span class="sd">               (for indexing details: https://www.nemo-ocean.eu/doc/img360.png )</span>
<span class="sd">               In 3D, the depth is the one corresponding to W nodes</span>
<span class="sd">        :param indices: Optional dictionary of indices for each dimension</span>
<span class="sd">               to read from file(s), to allow for reading of subset of data.</span>
<span class="sd">               Default is to read the full extent of each dimension.</span>
<span class="sd">               Note that negative indices are not allowed.</span>
<span class="sd">        :param fieldtype: Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.</span>
<span class="sd">               (either &#39;U&#39;, &#39;V&#39;, &#39;Kh_zonal&#39;, &#39;Kh_meridional&#39; or None)</span>
<span class="sd">        :param mesh: String indicating the type of mesh coordinates and</span>
<span class="sd">               units used during velocity interpolation:</span>

<span class="sd">               1. spherical (default): Lat and lon in degree, with a</span>
<span class="sd">                  correction for zonal velocity U near the poles.</span>
<span class="sd">               2. flat: No conversion, lat/lon are assumed to be in m.</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        :param tracer_interp_method: Method for interpolation of tracer fields. It is recommended to use &#39;cgrid_tracer&#39; (default)</span>
<span class="sd">               Note that in the case of from_nemo() and from_cgrid(), the velocity fields are default to &#39;cgrid_velocity&#39;</span>
<span class="sd">        :param field_chunksize: size of the chunks in dask loading</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;U&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="s1">&#39;V&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;On a c-grid discretisation like NEMO, U and V should have the same dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;U&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="s1">&#39;W&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;W&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;On a c-grid discretisation like NEMO, U, V and W should have the same dimensions&quot;</span><span class="p">)</span>

        <span class="n">interp_method</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">]:</span>
                <span class="n">interp_method</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cgrid_velocity&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interp_method</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">tracer_interp_method</span>
        <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_c_grid_dataset&#39;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_netcdf</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span>
                               <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">,</span>
                               <span class="n">field_chunksize</span><span class="o">=</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.from_pop"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_pop">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pop</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span>
                 <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">tracer_interp_method</span><span class="o">=</span><span class="s1">&#39;bgrid_tracer&#39;</span><span class="p">,</span> <span class="n">field_chunksize</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises FieldSet object from NetCDF files of POP fields.</span>
<span class="sd">            It is assumed that the velocities in the POP fields is in cm/s.</span>

<span class="sd">        :param filenames: Dictionary mapping variables to file(s). The</span>
<span class="sd">               filepath may contain wildcards to indicate multiple files,</span>
<span class="sd">               or be a list of file.</span>
<span class="sd">               filenames can be a list [files], a dictionary {var:[files]},</span>
<span class="sd">               a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),</span>
<span class="sd">               or a dictionary of dictionaries {var:{dim:[files]}}</span>
<span class="sd">               time values are in filenames[data]</span>
<span class="sd">        :param variables: Dictionary mapping variables to variable names in the netCDF file(s).</span>
<span class="sd">               Note that the built-in Advection kernels assume that U and V are in m/s</span>
<span class="sd">        :param dimensions: Dictionary mapping data dimensions (lon,</span>
<span class="sd">               lat, depth, time, data) to dimensions in the netCF file(s).</span>
<span class="sd">               Note that dimensions can also be a dictionary of dictionaries if</span>
<span class="sd">               dimension names are different for each variable.</span>
<span class="sd">               Watch out: POP is discretised on a B-grid:</span>
<span class="sd">               U and V velocity nodes are not located as W velocity and T tracer nodes (see http://www.cesm.ucar.edu/models/cesm1.0/pop2/doc/sci/POPRefManual.pdf ).</span>
<span class="sd">               U[k,j+1,i],V[k,j+1,i] ____________________U[k,j+1,i+1],V[k,j+1,i+1]</span>
<span class="sd">               |                                         |</span>
<span class="sd">               |      W[k:k+2,j+1,i+1],T[k,j+1,i+1]      |</span>
<span class="sd">               |                                         |</span>
<span class="sd">               U[k,j,i],V[k,j,i] ________________________U[k,j,i+1],V[k,j,i+1]</span>
<span class="sd">               In 2D: U and V nodes are on the cell vertices and interpolated bilinearly as a A-grid.</span>
<span class="sd">                      T node is at the cell centre and interpolated constant per cell as a C-grid.</span>
<span class="sd">               In 3D: U and V nodes are at the midlle of the cell vertical edges,</span>
<span class="sd">                      They are interpolated bilinearly (independently of z) in the cell.</span>
<span class="sd">                      W nodes are at the centre of the horizontal interfaces.</span>
<span class="sd">                      They are interpolated linearly (as a function of z) in the cell.</span>
<span class="sd">                      T node is at the cell centre, and constant per cell.</span>
<span class="sd">        :param indices: Optional dictionary of indices for each dimension</span>
<span class="sd">               to read from file(s), to allow for reading of subset of data.</span>
<span class="sd">               Default is to read the full extent of each dimension.</span>
<span class="sd">               Note that negative indices are not allowed.</span>
<span class="sd">        :param fieldtype: Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.</span>
<span class="sd">               (either &#39;U&#39;, &#39;V&#39;, &#39;Kh_zonal&#39;, &#39;Kh_meridional&#39; or None)</span>
<span class="sd">        :param mesh: String indicating the type of mesh coordinates and</span>
<span class="sd">               units used during velocity interpolation, see also https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb:</span>

<span class="sd">               1. spherical (default): Lat and lon in degree, with a</span>
<span class="sd">                  correction for zonal velocity U near the poles.</span>
<span class="sd">               2. flat: No conversion, lat/lon are assumed to be in m.</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        :param tracer_interp_method: Method for interpolation of tracer fields. It is recommended to use &#39;bgrid_tracer&#39; (default)</span>
<span class="sd">               Note that in the case of from_pop() and from_bgrid(), the velocity fields are default to &#39;bgrid_velocity&#39;</span>
<span class="sd">        :param field_chunksize: size of the chunks in dask loading</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_pop&#39;</span>
        <span class="n">fieldset</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_b_grid_dataset</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span>
                                           <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span> <span class="n">tracer_interp_method</span><span class="o">=</span><span class="n">tracer_interp_method</span><span class="p">,</span>
                                           <span class="n">field_chunksize</span><span class="o">=</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fieldset</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">):</span>
            <span class="n">fieldset</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">set_scaling_factor</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># cm/s to m/s</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fieldset</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
            <span class="n">fieldset</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">set_scaling_factor</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># cm/s to m/s</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fieldset</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">):</span>
            <span class="n">fieldset</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">set_scaling_factor</span><span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># cm/s to m/s and change the W direction</span>
        <span class="k">return</span> <span class="n">fieldset</span></div>

<div class="viewcode-block" id="FieldSet.from_b_grid_dataset"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_b_grid_dataset">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_b_grid_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span>
                            <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">tracer_interp_method</span><span class="o">=</span><span class="s1">&#39;bgrid_tracer&#39;</span><span class="p">,</span> <span class="n">field_chunksize</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises FieldSet object from NetCDF files of Bgrid fields.</span>

<span class="sd">        :param filenames: Dictionary mapping variables to file(s). The</span>
<span class="sd">               filepath may contain wildcards to indicate multiple files,</span>
<span class="sd">               or be a list of file.</span>
<span class="sd">               filenames can be a list [files], a dictionary {var:[files]},</span>
<span class="sd">               a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),</span>
<span class="sd">               or a dictionary of dictionaries {var:{dim:[files]}}</span>
<span class="sd">               time values are in filenames[data]</span>
<span class="sd">        :param variables: Dictionary mapping variables to variable</span>
<span class="sd">               names in the netCDF file(s).</span>
<span class="sd">        :param dimensions: Dictionary mapping data dimensions (lon,</span>
<span class="sd">               lat, depth, time, data) to dimensions in the netCF file(s).</span>
<span class="sd">               Note that dimensions can also be a dictionary of dictionaries if</span>
<span class="sd">               dimension names are different for each variable.</span>
<span class="sd">               U and V velocity nodes are not located as W velocity and T tracer nodes (see http://www.cesm.ucar.edu/models/cesm1.0/pop2/doc/sci/POPRefManual.pdf ).</span>
<span class="sd">               U[k,j+1,i],V[k,j+1,i] ____________________U[k,j+1,i+1],V[k,j+1,i+1]</span>
<span class="sd">               |                                         |</span>
<span class="sd">               |      W[k:k+2,j+1,i+1],T[k,j+1,i+1]      |</span>
<span class="sd">               |                                         |</span>
<span class="sd">               U[k,j,i],V[k,j,i] ________________________U[k,j,i+1],V[k,j,i+1]</span>
<span class="sd">               In 2D: U and V nodes are on the cell vertices and interpolated bilinearly as a A-grid.</span>
<span class="sd">                      T node is at the cell centre and interpolated constant per cell as a C-grid.</span>
<span class="sd">               In 3D: U and V nodes are at the midlle of the cell vertical edges,</span>
<span class="sd">                      They are interpolated bilinearly (independently of z) in the cell.</span>
<span class="sd">                      W nodes are at the centre of the horizontal interfaces.</span>
<span class="sd">                      They are interpolated linearly (as a function of z) in the cell.</span>
<span class="sd">                      T node is at the cell centre, and constant per cell.</span>
<span class="sd">        :param indices: Optional dictionary of indices for each dimension</span>
<span class="sd">               to read from file(s), to allow for reading of subset of data.</span>
<span class="sd">               Default is to read the full extent of each dimension.</span>
<span class="sd">               Note that negative indices are not allowed.</span>
<span class="sd">        :param fieldtype: Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.</span>
<span class="sd">               (either &#39;U&#39;, &#39;V&#39;, &#39;Kh_zonal&#39;, &#39;Kh_meridional&#39; or None)</span>
<span class="sd">        :param mesh: String indicating the type of mesh coordinates and</span>
<span class="sd">               units used during velocity interpolation:</span>

<span class="sd">               1. spherical (default): Lat and lon in degree, with a</span>
<span class="sd">                  correction for zonal velocity U near the poles.</span>
<span class="sd">               2. flat: No conversion, lat/lon are assumed to be in m.</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        :param tracer_interp_method: Method for interpolation of tracer fields. It is recommended to use &#39;bgrid_tracer&#39; (default)</span>
<span class="sd">               Note that in the case of from_pop() and from_bgrid(), the velocity fields are default to &#39;bgrid_velocity&#39;</span>
<span class="sd">        :param field_chunksize: size of the chunks in dask loading</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;U&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="s1">&#39;V&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;On a B-grid discretisation, U and V should have the same dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;U&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="s1">&#39;W&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;W&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;On a B-grid discretisation, U, V and W should have the same dimensions&quot;</span><span class="p">)</span>

        <span class="n">interp_method</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">]:</span>
                <span class="n">interp_method</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bgrid_velocity&#39;</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;W&#39;</span><span class="p">]:</span>
                <span class="n">interp_method</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bgrid_w_velocity&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interp_method</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">tracer_interp_method</span>
        <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_b_grid_dataset&#39;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_netcdf</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span>
                               <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">,</span>
                               <span class="n">field_chunksize</span><span class="o">=</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.from_parcels"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_parcels">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_parcels</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">uvar</span><span class="o">=</span><span class="s1">&#39;vozocrtx&#39;</span><span class="p">,</span> <span class="n">vvar</span><span class="o">=</span><span class="s1">&#39;vomecrty&#39;</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deferred_load</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">field_chunksize</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises FieldSet data from NetCDF files using the Parcels FieldSet.write() conventions.</span>

<span class="sd">        :param basename: Base name of the file(s); may contain</span>
<span class="sd">               wildcards to indicate multiple files.</span>
<span class="sd">        :param indices: Optional dictionary of indices for each dimension</span>
<span class="sd">               to read from file(s), to allow for reading of subset of data.</span>
<span class="sd">               Default is to read the full extent of each dimension.</span>
<span class="sd">               Note that negative indices are not allowed.</span>
<span class="sd">        :param fieldtype: Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.</span>
<span class="sd">               (either &#39;U&#39;, &#39;V&#39;, &#39;Kh_zonal&#39;, &#39;Kh_meridional&#39; or None)</span>
<span class="sd">        :param extra_fields: Extra fields to read beyond U and V</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        :param deferred_load: boolean whether to only pre-load data (in deferred mode) or</span>
<span class="sd">               fully load them (default: True). It is advised to deferred load the data, since in</span>
<span class="sd">               that case Parcels deals with a better memory management during particle set execution.</span>
<span class="sd">               deferred_load=False is however sometimes necessary for plotting the fields.</span>
<span class="sd">        :param field_chunksize: size of the chunks in dask loading</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">extra_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extra_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_parcels&#39;</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">default_dims</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="s1">&#39;nav_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="s1">&#39;nav_lat&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="s1">&#39;time_counter&#39;</span><span class="p">}</span>
        <span class="n">extra_fields</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="n">uvar</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="n">vvar</span><span class="p">})</span>
        <span class="k">for</span> <span class="nb">vars</span> <span class="ow">in</span> <span class="n">extra_fields</span><span class="p">:</span>
            <span class="n">dimensions</span><span class="p">[</span><span class="nb">vars</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">default_dims</span><span class="p">)</span>
            <span class="n">dimensions</span><span class="p">[</span><span class="nb">vars</span><span class="p">][</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;depth</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">vars</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">.nc&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
                          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">extra_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_netcdf</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="n">extra_fields</span><span class="p">,</span>
                               <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span>
                               <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span> <span class="n">deferred_load</span><span class="o">=</span><span class="n">deferred_load</span><span class="p">,</span>
                               <span class="n">field_chunksize</span><span class="o">=</span><span class="n">field_chunksize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.from_xarray_dataset"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.from_xarray_dataset">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_xarray_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span> <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">time_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises FieldSet data from xarray Datasets.</span>

<span class="sd">        :param ds: xarray Dataset.</span>
<span class="sd">               Note that the built-in Advection kernels assume that U and V are in m/s</span>
<span class="sd">        :param variables: Dictionary mapping parcels variable names to data variables in the xarray Dataset.</span>
<span class="sd">        :param dimensions: Dictionary mapping data dimensions (lon,</span>
<span class="sd">               lat, depth, time, data) to dimensions in the xarray Dataset.</span>
<span class="sd">               Note that dimensions can also be a dictionary of dictionaries if</span>
<span class="sd">               dimension names are different for each variable</span>
<span class="sd">               (e.g. dimensions[&#39;U&#39;], dimensions[&#39;V&#39;], etc).</span>
<span class="sd">        :param fieldtype: Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.</span>
<span class="sd">               (either &#39;U&#39;, &#39;V&#39;, &#39;Kh_zonal&#39;, &#39;Kh_meridional&#39; or None)</span>
<span class="sd">        :param mesh: String indicating the type of mesh coordinates and</span>
<span class="sd">               units used during velocity interpolation, see also https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb:</span>

<span class="sd">               1. spherical (default): Lat and lon in degree, with a</span>
<span class="sd">                  correction for zonal velocity U near the poles.</span>
<span class="sd">               2. flat: No conversion, lat/lon are assumed to be in m.</span>
<span class="sd">        :param allow_time_extrapolation: boolean whether to allow for extrapolation</span>
<span class="sd">               (i.e. beyond the last available time snapshot)</span>
<span class="sd">               Default is False if dimensions includes time, else True</span>
<span class="sd">        :param time_periodic: To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)</span>
<span class="sd">               This flag overrides the allow_time_interpolation and sets it to False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;creation_log&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;creation_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;from_xarray_dataset&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;units&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span> <span class="ow">and</span> <span class="s1">&#39;Unit&#39;</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="c1"># Fix DataArrays that have time.Unit instead of expected time.units</span>
                <span class="n">convert_xarray_time_units</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">else</span> <span class="n">dimensions</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">checkvaliddimensionsdict</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

            <span class="n">fields</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">var</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="n">allow_time_extrapolation</span><span class="p">,</span>
                                            <span class="n">time_periodic</span><span class="o">=</span><span class="n">time_periodic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.get_fields"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.get_fields">[docs]</a>    <span class="k">def</span> <span class="nf">get_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of all the :class:`parcels.field.Field` and :class:`parcels.field.VectorField`</span>
<span class="sd">        objects associated with this FieldSet&quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Field</span><span class="p">,</span> <span class="n">VectorField</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                    <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">NestedField</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                    <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                        <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fields</span></div>

<div class="viewcode-block" id="FieldSet.add_constant"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.add_constant">[docs]</a>    <span class="k">def</span> <span class="nf">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a constant to the FieldSet. Note that all constants are</span>
<span class="sd">        stored as 32-bit floats. While constants can be updated during</span>
<span class="sd">        execution in SciPy mode, they can not be updated in JIT mode.</span>

<span class="sd">        :param name: Name of the constant</span>
<span class="sd">        :param value: Value of the constant (stored as 32-bit float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.add_periodic_halo"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.add_periodic_halo">[docs]</a>    <span class="k">def</span> <span class="nf">add_periodic_halo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">meridional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">halosize</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a &#39;halo&#39; to all :class:`parcels.field.Field` objects in a FieldSet,</span>
<span class="sd">        through extending the Field (and lon/lat) by copying a small portion</span>
<span class="sd">        of the field on one side of the domain to the other.</span>

<span class="sd">        :param zonal: Create a halo in zonal direction (boolean)</span>
<span class="sd">        :param meridional: Create a halo in meridional direction (boolean)</span>
<span class="sd">        :param halosize: size of the halo (in grid points). Default is 5 grid points</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridset</span><span class="o">.</span><span class="n">grids</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">add_periodic_halo</span><span class="p">(</span><span class="n">zonal</span><span class="p">,</span> <span class="n">meridional</span><span class="p">,</span> <span class="n">halosize</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
                <span class="n">value</span><span class="o">.</span><span class="n">add_periodic_halo</span><span class="p">(</span><span class="n">zonal</span><span class="p">,</span> <span class="n">meridional</span><span class="p">,</span> <span class="n">halosize</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.write"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write FieldSet to NetCDF file using NEMO convention</span>

<span class="sd">        :param filename: Basename of the output fileset&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">MPI</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Generating FieldSet output with basename: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">varname</span><span class="o">=</span><span class="s1">&#39;vozocrtx&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">varname</span><span class="o">=</span><span class="s1">&#39;vomecrty&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.advancetime"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.advancetime">[docs]</a>    <span class="k">def</span> <span class="nf">advancetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldset_new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace oldest time on FieldSet with new FieldSet</span>
<span class="sd">        :param fieldset_new: FieldSet snapshot with which the oldest time has to be replaced&quot;&quot;&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">warning_once</span><span class="p">(</span><span class="s2">&quot;Fieldset.advancetime() is deprecated.</span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                             Parcels deals automatically with loading only 3 time steps simustaneously</span><span class="se">\</span>
<span class="s2">                             such that the total allocated memory remains limited.&quot;</span><span class="p">)</span>

        <span class="n">advance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">gnew</span> <span class="ow">in</span> <span class="n">fieldset_new</span><span class="o">.</span><span class="n">gridset</span><span class="o">.</span><span class="n">grids</span><span class="p">:</span>
            <span class="n">gnew</span><span class="o">.</span><span class="n">advanced</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">fnew</span> <span class="ow">in</span> <span class="n">fieldset_new</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fnew</span><span class="p">,</span> <span class="n">VectorField</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fnew</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">gnew</span> <span class="o">=</span> <span class="n">fnew</span><span class="o">.</span><span class="n">grid</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gnew</span><span class="o">.</span><span class="n">advanced</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span>
                <span class="n">advance2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">advancetime</span><span class="p">(</span><span class="n">gnew</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">advance2</span><span class="o">*</span><span class="n">advance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Some Fields of the Fieldset are advanced forward and other backward&quot;</span><span class="p">)</span>
                <span class="n">advance</span> <span class="o">=</span> <span class="n">advance2</span>
                <span class="n">gnew</span><span class="o">.</span><span class="n">advanced</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">f</span><span class="o">.</span><span class="n">advancetime</span><span class="p">(</span><span class="n">fnew</span><span class="p">,</span> <span class="n">advance</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldSet.computeTimeChunk"><a class="viewcode-back" href="../../index.html#parcels.fieldset.FieldSet.computeTimeChunk">[docs]</a>    <span class="k">def</span> <span class="nf">computeTimeChunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a chunk of three data time steps into the FieldSet.</span>
<span class="sd">        This is used when FieldSet uses data imported from netcdf,</span>
<span class="sd">        with default option deferred_load. The loaded time steps are at or immediatly before time</span>
<span class="sd">        and the two time steps immediately following time if dt is positive (and inversely for negative dt)</span>
<span class="sd">        :param time: Time around which the FieldSet chunks are to be loaded. Time is provided as a double, relatively to Fieldset.time_origin</span>
<span class="sd">        :param dt: time step of the integration scheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">signdt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">nextTime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span> <span class="k">if</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">infty</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridset</span><span class="o">.</span><span class="n">grids</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">update_status</span> <span class="o">=</span> <span class="s1">&#39;not_updated&#39;</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">VectorField</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">defer_load</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">update_status</span> <span class="o">==</span> <span class="s1">&#39;not_updated&#39;</span><span class="p">:</span>
                <span class="n">nextTime_loc</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">computeTimeChunk</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">signdt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">time</span> <span class="o">==</span> <span class="n">nextTime_loc</span> <span class="ow">and</span> <span class="n">signdt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TimeExtrapolationError</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;In fset.computeTimeChunk&#39;</span><span class="p">)</span>
            <span class="n">nextTime</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nextTime</span><span class="p">,</span> <span class="n">nextTime_loc</span><span class="p">)</span> <span class="k">if</span> <span class="n">signdt</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">nextTime</span><span class="p">,</span> <span class="n">nextTime_loc</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">VectorField</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">defer_load</span> <span class="ow">or</span> <span class="n">f</span><span class="o">.</span><span class="n">dataFiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">update_status</span> <span class="o">==</span> <span class="s1">&#39;first_updated&#39;</span><span class="p">:</span>  <span class="c1"># First load of data</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">DeferredArray</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
                            <span class="k">del</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">g</span><span class="o">.</span><span class="n">tdim</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">zdim</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">ydim</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">meridional_halo</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xdim</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">zonal_halo</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">loaded_time_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tind</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">loaded_time_indices</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fb</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">fb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">fb</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">fb</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">computeTimeChunk</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tind</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">rescale_and_set_minmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">DeferredArray</span><span class="p">)):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DeferredArray</span><span class="p">()</span>
                <span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">chunk_set</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">chunk_setup</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">update_status</span> <span class="o">==</span> <span class="s1">&#39;updated&#39;</span><span class="p">:</span>
                <span class="n">lib</span> <span class="o">=</span> <span class="n">np</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">da</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">g</span><span class="o">.</span><span class="n">tdim</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">zdim</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">ydim</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">meridional_halo</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xdim</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">zonal_halo</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">signdt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">loaded_time_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">computeTimeChunk</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">loaded_time_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">filebuffers</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">computeTimeChunk</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">rescale_and_set_minmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">signdt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span>
                    <span class="k">if</span> <span class="n">lib</span> <span class="ow">is</span> <span class="n">da</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:],</span> <span class="n">data</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">DeferredArray</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                                <span class="k">del</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">if</span> <span class="n">lib</span> <span class="ow">is</span> <span class="n">da</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">DeferredArray</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                                <span class="k">del</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">signdt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">block_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">)):</span>
                            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">[</span><span class="n">block_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="c1"># file chunks were never loaded.</span>
                                    <span class="c1"># happens when field not called by kernel, but shares a grid with another field called by kernel</span>
                                    <span class="k">break</span>
                                <span class="n">block</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">blocks</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">),)</span><span class="o">+</span><span class="n">block</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">block_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">)):</span>
                            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">load_chunk</span><span class="p">[</span><span class="n">block_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="c1"># file chunks were never loaded.</span>
                                    <span class="c1"># happens when field not called by kernel, but shares a grid with another field called by kernel</span>
                                    <span class="k">break</span>
                                <span class="n">block</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">data_chunks</span><span class="p">[</span><span class="n">block_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">blocks</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">),)</span><span class="o">+</span><span class="n">block</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># do user-defined computations on fieldset data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_on_defer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_on_defer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># update time varying grid depth</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fields</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">VectorField</span><span class="p">,</span> <span class="n">NestedField</span><span class="p">,</span> <span class="n">SummedField</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">defer_load</span> <span class="ow">or</span> <span class="n">f</span><span class="o">.</span><span class="n">dataFiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">depth_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">depth_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">depth_field</span><span class="o">.</span><span class="n">data</span>
                <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth_data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">depth_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">depth_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">nextTime</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">nextTime</span><span class="p">):</span>  <span class="c1"># Second happens when dt=0</span>
            <span class="k">return</span> <span class="n">nextTime</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nextTime</span> <span class="o">-</span> <span class="n">time</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nSteps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">nextTime</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">time</span> <span class="o">+</span> <span class="n">nSteps</span> <span class="o">*</span> <span class="n">dt</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Parcels  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Michael Lange and Erik van Sebille.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>