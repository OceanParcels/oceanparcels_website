

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>parcels.particlesets.collectionsoa &#8212; Parcels 2.2.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />

    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-96368922-1', 'auto');
  ga('send', 'pageview');
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Parcels 2.2.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">parcels.particlesets.collectionsoa</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for parcels.particlesets.collectionsoa</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span> <span class="k">as</span> <span class="n">delta</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">POINTER</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.collections</span> <span class="kn">import</span> <span class="n">ParticleCollection</span>
<span class="kn">from</span> <span class="nn">.iterators</span> <span class="kn">import</span> <span class="n">BaseParticleAccessor</span>
<span class="kn">from</span> <span class="nn">.iterators</span> <span class="kn">import</span> <span class="n">BaseParticleCollectionIterator</span>
<span class="kn">from</span> <span class="nn">parcels.particle</span> <span class="kn">import</span> <span class="n">ScipyParticle</span><span class="p">,</span> <span class="n">JITParticle</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">parcels.field</span> <span class="kn">import</span> <span class="n">Field</span>
<span class="kn">from</span> <span class="nn">parcels.tools.loggers</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">parcels.tools.statuscodes</span> <span class="kn">import</span> <span class="n">OperationCode</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">MPI</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">MPI</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">EnvironmentError</span><span class="p">(</span><span class="s1">&#39;sklearn needs to be available if MPI is installed. &#39;</span>
                               <span class="s1">&#39;See http://oceanparcels.org/#parallel_install for more information&#39;</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Author: Dr. Christian Kehl</span>
<span class="sd">github relation: #913 (particleset_class_hierarchy)</span>
<span class="sd">purpose: defines all the specific functions for a ParticleCollection, ParticleAccessor, ParticleSet etc. that relates</span>
<span class="sd">         to a structure-of-array (SoA) data arrangement.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_to_write_particles</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;We don&#39;t want to write a particle that is not started yet.</span>
<span class="sd">    Particle will be written if particle.time is between time-dt/2 and time+dt (/2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">pd</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]))</span>
            <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pd</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]))</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]))</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])))</span>


<span class="k">def</span> <span class="nf">_is_particle_started_yet</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;We don&#39;t want to write a particle that is not started yet.</span>
<span class="sd">    Particle will be written if:</span>
<span class="sd">      * particle.time is equal to time argument of pfile.write()</span>
<span class="sd">      * particle.time is before time (in case particle was deleted between previous export and current one)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">pd</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">time</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">time</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_convert_to_flat_array</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert lists and single integers/floats to one-dimensional numpy arrays</span>

<span class="sd">    :param var: list or numeric to convert to a one-dimensional numpy array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">var</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>


<div class="viewcode-block" id="ParticleCollectionSOA"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA">[docs]</a><span class="k">class</span> <span class="nc">ParticleCollectionSOA</span><span class="p">(</span><span class="n">ParticleCollection</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pclass</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">lonlatdepth_dtype</span><span class="p">,</span> <span class="n">pid_orig</span><span class="p">,</span> <span class="n">partitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngrid</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ngrid: number of grids in the fieldset of the overarching ParticleSet - required for initialising the</span>
<span class="sd">        field references of the ctypes-link of particles that are allocated</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ParticleCollection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">pid_orig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;particle IDs are None - incompatible with the collection. Invalid state.&quot;</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">pid_orig</span> <span class="o">+</span> <span class="n">pclass</span><span class="o">.</span><span class="n">lastID</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;particle&#39;s initial depth is None - incompatible with the collection. Invalid state.&quot;</span>
        <span class="k">assert</span> <span class="n">lon</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">lat</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">lon</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">depth</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;lon, lat, depth don&#39;&#39;t all have the same lenghts&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">lon</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;time and positions (lon, lat, depth) don&#39;&#39;t have the same lengths.&#39;</span><span class="p">)</span>

        <span class="c1"># If partitions is false, the partitions are already initialised</span>
        <span class="k">if</span> <span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">=</span> <span class="n">_convert_to_flat_array</span><span class="p">(</span><span class="n">partitions</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">kwvar</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">lon</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kwvar</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> and positions (lon, lat, depth) don&#39;&#39;t have the same lengths.&#39;</span> <span class="o">%</span> <span class="n">kwvar</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">MPI</span><span class="p">:</span>
            <span class="n">mpi_comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="n">mpi_rank</span> <span class="o">=</span> <span class="n">mpi_comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
            <span class="n">mpi_size</span> <span class="o">=</span> <span class="n">mpi_comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">lon</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">mpi_size</span> <span class="ow">and</span> <span class="n">mpi_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot initialise with fewer particles than MPI processors&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mpi_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">mpi_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">=</span> <span class="n">mpi_comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mpi_size</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Particle partitions must vary between 0 and the number of mpi procs&#39;</span><span class="p">)</span>
                    <span class="n">lon</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">==</span> <span class="n">mpi_rank</span><span class="p">]</span>
                    <span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">==</span> <span class="n">mpi_rank</span><span class="p">]</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">==</span> <span class="n">mpi_rank</span><span class="p">]</span>
                    <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">==</span> <span class="n">mpi_rank</span><span class="p">]</span>
                    <span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">==</span> <span class="n">mpi_rank</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">kwvar</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">kwvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kwvar</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">==</span> <span class="n">mpi_rank</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>

        <span class="n">pclass</span><span class="o">.</span><span class="n">setLastID</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lonlatdepth_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lonlatdepth_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lonlatdepth_dtype</span> <span class="o">=</span> <span class="n">lonlatdepth_dtype</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lonlatdepth_dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> \
            <span class="s1">&#39;lon lat depth precision should be set to either np.float32 or np.float64&#39;</span>
        <span class="n">pclass</span><span class="o">.</span><span class="n">set_lonlatdepth_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lonlatdepth_dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pclass</span> <span class="o">=</span> <span class="n">pclass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span> <span class="o">=</span> <span class="n">pclass</span><span class="o">.</span><span class="n">getPType</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">initialised</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">,</span> <span class="s1">&#39;yi&#39;</span><span class="p">,</span> <span class="s1">&#39;zi&#39;</span><span class="p">,</span> <span class="s1">&#39;ti&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">ngrid</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">lon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Initialise from lists of lon/lat coordinates</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncount</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncount</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;Size of ParticleSet does not match length of lon and lat.&#39;</span><span class="p">)</span>

            <span class="c1"># mimic the variables that get initialised in the constructor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">lat</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">lon</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">pid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;fileid&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># special case for exceptions which can only be handled from scipy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;exception&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncount</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

            <span class="n">initialised</span> <span class="o">|=</span> <span class="p">{</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">}</span>

            <span class="c1"># any fields that were provided on the command line</span>
            <span class="k">for</span> <span class="n">kwvar</span><span class="p">,</span> <span class="n">kwval</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pclass</span><span class="p">,</span> <span class="n">kwvar</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Particle class does not have Variable </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwvar</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">kwvar</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">kwval</span>
                <span class="n">initialised</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">kwvar</span><span class="p">)</span>

            <span class="c1"># initialise the rest to their default values</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">initialised</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">initial</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncount</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot initialise a Variable with a Field if no time provided (time-type: </span><span class="si">{}</span><span class="s1"> values: </span><span class="si">{}</span><span class="s1">). Add a &quot;time=&quot; to ParticleSet construction&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">time</span><span class="p">))</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">initial</span><span class="o">.</span><span class="n">fieldset</span><span class="o">.</span><span class="n">computeTimeChunk</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">initial</span><span class="p">[</span>
                            <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="p">]</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning_once</span><span class="p">(</span><span class="s2">&quot;Particle initialisation from field can be very slow as it is computed in scipy mode.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">initial</span><span class="p">,</span> <span class="n">attrgetter</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">initial</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">initial</span>

                <span class="n">initialised</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Latitude and longitude required for generating ParticleSet&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collection - Destructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an Iterator that allows for forward iteration over the</span>
<span class="sd">        elements in the ParticleCollection (e.g. `for p in pset:`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParticleCollectionIteratorSOA</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an Iterator that allows for backwards iteration over</span>
<span class="sd">        the elements in the ParticleCollection (e.g.</span>
<span class="sd">        `for p in reversed(pset):`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParticleCollectionIteratorSOA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access a particle in this collection using the fastest access</span>
<span class="sd">        method for this collection - by its index.</span>

<span class="sd">        :param index: int or np.int32 index of a particle in this collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access a single property of all particles.</span>

<span class="sd">        :param name: name of the property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="ParticleCollectionSOA.get_single_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets a (particle) object from the collection based on its index within the collection. For</span>
<span class="sd">        collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a</span>
<span class="sd">        translation of the index into the specific object reference in the collection - or (if unavoidable) the</span>
<span class="sd">        translation of the collection from a none-indexable, none-random-access structure into an indexable structure.</span>
<span class="sd">        In cases where a get-by-index would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        get function, e.g. get-by-ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_single_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ParticleAccessorSOA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.get_single_by_object"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_object">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_by_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets a (particle) object from the collection based on its actual object. For collections that</span>
<span class="sd">        are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function</span>
<span class="sd">        would involve a parsing of the whole list and translation of the object into an index in the collection - which</span>
<span class="sd">        results in a significant performance malus.</span>
<span class="sd">        In cases where a get-by-object would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        get function, e.g. get-by-index or get-by-ID.</span>

<span class="sd">        In this specific implementation, we cannot look for the object</span>
<span class="sd">        directly, so we will look for one of its properties (the ID) that</span>
<span class="sd">        has the nice property of being stored in an ordered list (if the</span>
<span class="sd">        collection is sorted)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_single_by_object</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_by_ID</span><span class="p">(</span><span class="n">particle_obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.get_single_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_ID">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets a (particle) object from the collection based on the object&#39;s ID. For some collections,</span>
<span class="sd">        this operation may involve a parsing of the whole list and translation of the object&#39;s ID into an index  or an</span>
<span class="sd">        object reference in the collection - which results in a significant performance malus.</span>
<span class="sd">        In cases where a get-by-ID would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        get function, e.g. get-by-index.</span>

<span class="sd">        This function uses binary search if we know the ID list to be sorted, and linear search otherwise. We assume</span>
<span class="sd">        IDs are unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_single_by_ID</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="c1"># Use binary search if the collection is sorted, linear search otherwise</span>
        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to access a particle with a non-existing ID: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.get_same"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_same">[docs]</a>    <span class="k">def</span> <span class="nf">get_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection that are themselves stored in another object of an equi-</span>
<span class="sd">        structured ParticleCollection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_same</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.get_collection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_collection">[docs]</a>    <span class="k">def</span> <span class="nf">get_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcollection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection that are themselves stored in a ParticleCollection, which</span>
<span class="sd">        is differently structured than this one. That means the other-collection has to be re-formatted first in an</span>
<span class="sd">        intermediary format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="n">pcollection</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.get_multi_by_PyCollection_Particles"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_PyCollection_Particles">[docs]</a>    <span class="k">def</span> <span class="nf">get_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pycollectionp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection, which are themselves in common Python collections, such as</span>
<span class="sd">        lists, dicts and numpy structures. We can either directly get the referred Particle instances (for internally-</span>
<span class="sd">        ordered collections, e.g. ordered lists, sets, trees) or we may need to parse each instance for its index (for</span>
<span class="sd">        random-access structures), which results in a considerable performance malus.</span>

<span class="sd">        For collections where get-by-object incurs a performance malus, it is advisable to multi-get particles</span>
<span class="sd">        by indices or IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="n">pycollectionp</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.get_multi_by_indices"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_multi_by_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection based on their indices. This works best for random-access</span>
<span class="sd">        collections (e.g. numpy&#39;s ndarrays, dense matrices and dense arrays), whereas internally ordered collections</span>
<span class="sd">        shall rather use a get-via-object-reference strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_multi_by_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ParticleCollectionIteratorSOA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.get_multi_by_IDs"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_IDs">[docs]</a>    <span class="k">def</span> <span class="nf">get_multi_by_IDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection based on their IDs. For collections where this removal</span>
<span class="sd">        strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a get-</span>
<span class="sd">        by-objects or get-by-indices scheme.</span>

<span class="sd">        Note that this implementation assumes that IDs of particles are strictly increasing with increasing index. So</span>
<span class="sd">        a particle with a larger index will always have a larger ID as well. The assumption often holds for this</span>
<span class="sd">        datastructure as new particles always get a larger ID than any existing particle (IDs are not recycled)</span>
<span class="sd">        and their data are appended at the end of the list (largest index). This allows for the use of binary search</span>
<span class="sd">        in the look-up. The collection maintains a `sorted` flag to indicate whether this assumption holds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_multi_by_IDs</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Use binary search if the collection is sorted, linear search otherwise</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span><span class="p">:</span>
            <span class="c1"># This is efficient if len(ids) &lt;&lt; self.len</span>
            <span class="n">sorted_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ids</span><span class="p">))</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_ID_lookup</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]),</span> <span class="n">sorted_ids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">ids</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multi_by_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_recursive_ID_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">sublist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Identify the middle element of the sublist and perform binary</span>
<span class="sd">        search on it.</span>

<span class="sd">        :param low: Lowerbound on the indices to search for IDs.</span>
<span class="sd">        :param high: Upperbound on the indices to search for IDs.</span>
<span class="sd">        :param sublist: (Sub)list of IDs to look for.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">median</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">],</span> <span class="n">sublist</span><span class="p">[</span><span class="n">median</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># edge case</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sublist</span><span class="p">[</span><span class="n">median</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># The edge-cases have to be handled slightly differently</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]):</span>
            <span class="c1"># Continue with the same bounds, but drop the median.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_ID_lookup</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">sublist</span><span class="p">,</span> <span class="n">median</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sublist</span><span class="p">[</span><span class="n">median</span><span class="p">]:</span>
            <span class="c1"># We can split, because we received the index that the median</span>
            <span class="c1"># ID would have been inserted in, but we do not return the</span>
            <span class="c1"># index and keep it in our search space.</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_ID_lookup</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sublist</span><span class="p">[:</span><span class="n">median</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_ID_lookup</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">sublist</span><span class="p">[</span><span class="n">median</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>

        <span class="c1"># Otherwise, we located the median, so we include it in our</span>
        <span class="c1"># result, and split the search space on it, without including it.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_ID_lookup</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sublist</span><span class="p">[:</span><span class="n">median</span><span class="p">])</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_ID_lookup</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">sublist</span><span class="p">[</span><span class="n">median</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">right</span><span class="p">))</span>

<div class="viewcode-block" id="ParticleCollectionSOA.add_collection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_collection">[docs]</a>    <span class="k">def</span> <span class="nf">add_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcollection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds another, differently structured ParticleCollection to this collection. This is done by, for example,</span>
<span class="sd">        appending/adding the items of the other collection to this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">pcollection</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.add_single"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_single">[docs]</a>    <span class="k">def</span> <span class="nf">add_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adding a single Particle to the collection - either as a &#39;Particle; object in parcels itself, or</span>
<span class="sd">        via its ParticleAccessor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_single</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.add_same"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_same">[docs]</a>    <span class="k">def</span> <span class="nf">add_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds another, equi-structured ParticleCollection to this collection. This is done by concatenating</span>
<span class="sd">        both collections. The fact that they are of the same ParticleCollection&#39;s derivative simplifies</span>
<span class="sd">        parsing and concatenation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_same</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">same_class</span><span class="o">.</span><span class="n">ncount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">same_class</span><span class="o">.</span><span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">=</span> <span class="n">same_class</span><span class="o">.</span><span class="n">ncount</span>
            <span class="k">return</span>

        <span class="c1"># Determine order of concatenation and update the sorted flag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span> <span class="ow">and</span> <span class="n">same_class</span><span class="o">.</span><span class="n">_sorted</span> \
           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">same_class</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">same_class</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">+=</span> <span class="n">same_class</span><span class="o">.</span><span class="n">ncount</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">same_class</span><span class="o">.</span><span class="n">_sorted</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">same_class</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">same_class</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">+=</span> <span class="n">same_class</span><span class="o">.</span><span class="n">ncount</span></div>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs an incremental addition of the equi-structured ParticleCollections, such to allow</span>

<span class="sd">        a += b,</span>

<span class="sd">        with &#39;a&#39; and &#39;b&#39; begin the two equi-structured objects (or: &#39;b&#39; being and individual object).</span>
<span class="sd">        This operation is equal to an in-place addition of (an) element(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_same</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="ParticleCollectionSOA.insert"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function allows to &#39;insert&#39; a Particle (as object or via its accessor) into this collection. This method</span>
<span class="sd">        needs to be specified to each collection individually. Some collections (e.g. unordered list) allow to define</span>
<span class="sd">        the index where the object is to be inserted. Some collections can optionally insert an object at a specific</span>
<span class="sd">        position - at a significant speed- and memory malus cost (e.g. vectors, arrays, dense matrices). Some</span>
<span class="sd">        collections that manage a specified indexing order internally (e.g. ordered lists, sets, trees), and thus</span>
<span class="sd">        have no use for an &#39;index&#39; parameter. For those collections with an internally-enforced order, the function</span>
<span class="sd">        mapping equates to:</span>

<span class="sd">        insert(obj) -&gt; add_single(obj)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.push"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.push">[docs]</a>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function pushes a Particle (as object or via its accessor) to the end of a collection (&#39;end&#39; definition</span>
<span class="sd">        depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,</span>
<span class="sd">        sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the</span>
<span class="sd">        end). For the collections, the function mapping equates to:</span>

<span class="sd">        int32 push(particle_obj) -&gt; add_single(particle_obj); return -1;</span>

<span class="sd">        This function further returns the index, at which position the Particle has been inserted. By definition,</span>
<span class="sd">        the index is positive, thus: a return of &#39;-1&#39; indicates push failure, NOT the last position in the collection.</span>
<span class="sd">        Furthermore, collections that do not work on an index-preserving manner also return &#39;-1&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.append"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function appends a Particle (as object or via its accessor) to the end of a collection (&#39;end&#39; definition</span>
<span class="sd">        depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,</span>
<span class="sd">        sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the</span>
<span class="sd">        end). For the collections, the function mapping equates to:</span>

<span class="sd">        append(particle_obj) -&gt; add_single(particle_obj)</span>

<span class="sd">        The function - in contrast to &#39;push&#39; - does not return the index of the inserted object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the high-performance method to delete a specific object from this collection.</span>
<span class="sd">        As the most-performant way depends on the specific collection in question, the function is abstract.</span>

<span class="sd">        Highlight for the specific implementation:</span>
<span class="sd">        The &#39;key&#39; parameter should still be evaluated for being a single or a multi-entry delete, and needs to check</span>
<span class="sd">        that it received the correct type of &#39;indexing&#39; argument (i.e. index, id or iterator).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_by_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<div class="viewcode-block" id="ParticleCollectionSOA.delete_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.delete_by_index">[docs]</a>    <span class="k">def</span> <span class="nf">delete_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method deletes a particle from the  the collection based on its index. It does not return the deleted item.</span>
<span class="sd">        Semantically, the function appears similar to the &#39;remove&#39; operation. That said, the function in OceanParcels -</span>
<span class="sd">        instead of directly deleting the particle - just raises the &#39;deleted&#39; status flag for the indexed particle.</span>
<span class="sd">        In result, the particle still remains in the collection. The functional interpretation of the &#39;deleted&#39; status</span>
<span class="sd">        is handled by &#39;recovery&#39; dictionary during simulation execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">delete_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">OperationCode</span><span class="o">.</span><span class="n">Delete</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.delete_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.delete_by_ID">[docs]</a>    <span class="k">def</span> <span class="nf">delete_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method deletes a particle from the  the collection based on its ID. It does not return the deleted item.</span>
<span class="sd">        Semantically, the function appears similar to the &#39;remove&#39; operation. That said, the function in OceanParcels -</span>
<span class="sd">        instead of directly deleting the particle - just raises the &#39;deleted&#39; status flag for the indexed particle.</span>
<span class="sd">        In result, the particle still remains in the collection. The functional interpretation of the &#39;deleted&#39; status</span>
<span class="sd">        is handled by &#39;recovery&#39; dictionary during simulation execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">delete_by_ID</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="c1"># Use binary search if the collection is sorted, linear search otherwise</span>
        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to delete a particle with a non-existing ID: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">delete_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_single_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_index">[docs]</a>    <span class="k">def</span> <span class="nf">remove_single_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes a (particle) object from the collection based on its index within the collection. For</span>
<span class="sd">        collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a</span>
<span class="sd">        translation of the index into the specific object reference in the collection - or (if unavoidable) the</span>
<span class="sd">        translation of the collection from a none-indexable, none-random-access structure into an indexable structure,</span>
<span class="sd">        and then perform the removal.</span>
<span class="sd">        In cases where a removal-by-index would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        removal functions, e.g. remove-by-object or remove-by-ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_single_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">-=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_single_by_object"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_object">[docs]</a>    <span class="k">def</span> <span class="nf">remove_single_by_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes a (particle) object from the collection based on its actual object. For collections that</span>
<span class="sd">        are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function</span>
<span class="sd">        would involves a parsing of the whole list and translation of the object into an index in the collection to</span>
<span class="sd">        perform the removal - which results in a significant performance malus.</span>
<span class="sd">        In cases where a removal-by-object would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        removal functions, e.g. remove-by-index or remove-by-ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_single_by_object</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">)</span>

        <span class="c1"># We cannot look for the object directly, so we will look for one of</span>
        <span class="c1"># its properties that has the nice property of being stored in an</span>
        <span class="c1"># ordered list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_single_by_ID</span><span class="p">(</span><span class="n">particle_obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_single_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_ID">[docs]</a>    <span class="k">def</span> <span class="nf">remove_single_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes a (particle) object from the collection based on the object&#39;s ID. For some collections,</span>
<span class="sd">        this operation may involve a parsing of the whole list and translation of the object&#39;s ID into an index  or an</span>
<span class="sd">        object reference in the collection in order to perform the removal - which results in a significant performance</span>
<span class="sd">        malus.</span>
<span class="sd">        In cases where a removal-by-ID would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        removal functions, e.g. remove-by-object or remove-by-index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_single_by_ID</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="c1"># Use binary search if the collection is sorted, linear search otherwise</span>
        <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to remove a particle with a non-existing ID: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">id</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_single_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_same"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_same">[docs]</a>    <span class="k">def</span> <span class="nf">remove_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection that are themselves stored in another object of an equi-</span>
<span class="sd">        structured ParticleCollection. As the structures of both collections are the same, a more efficient M-in-N</span>
<span class="sd">        removal can be applied without an in-between reformatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_same</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_collection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_collection">[docs]</a>    <span class="k">def</span> <span class="nf">remove_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcollection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection that are themselves stored in a ParticleCollection, which</span>
<span class="sd">        is differently structured than this one. Tht means the removal first requires the removal-collection to be re-</span>
<span class="sd">        formatted in an intermediary format, before executing the removal.</span>
<span class="sd">        That said, this method should still be at least as efficient as a removal via common Python collections (i.e.</span>
<span class="sd">        lists, dicts, numpy&#39;s nD arrays &amp; dense arrays). Despite this, due to the reformatting, in some cases it may</span>
<span class="sd">        be more efficient to remove items then rather by IDs oder indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_collection</span><span class="p">(</span><span class="n">pcollection</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_multi_by_PyCollection_Particles"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_PyCollection_Particles">[docs]</a>    <span class="k">def</span> <span class="nf">remove_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pycollectionp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection, which are themselves in common Python collections, such as</span>
<span class="sd">        lists, dicts and numpy structures. In order to perform the removal, we can either directly remove the referred</span>
<span class="sd">        Particle instances (for internally-ordered collections, e.g. ordered lists, sets, trees) or we may need to parse</span>
<span class="sd">        each instance for its index (for random-access structures), which results in a considerable performance malus.</span>

<span class="sd">        For collections where removal-by-object incurs a performance malus, it is advisable to multi-remove particles</span>
<span class="sd">        by indices or IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="n">pycollectionp</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_multi_by_indices"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_indices">[docs]</a>    <span class="k">def</span> <span class="nf">remove_multi_by_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection based on their indices. This works best for random-access</span>
<span class="sd">        collections (e.g. numpy&#39;s ndarrays, dense matrices and dense arrays), whereas internally ordered collections</span>
<span class="sd">        shall rather use a removal-via-object-reference strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_multi_by_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.remove_multi_by_IDs"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_IDs">[docs]</a>    <span class="k">def</span> <span class="nf">remove_multi_by_IDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection based on their IDs. For collections where this removal</span>
<span class="sd">        strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a removal-</span>
<span class="sd">        by-objects or removal-by-indices scheme.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_multi_by_IDs</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Use binary search if the collection is sorted, linear search otherwise</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span><span class="p">:</span>
            <span class="c1"># This is efficient if len(ids) &lt;&lt; self.len</span>
            <span class="n">sorted_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ids</span><span class="p">))</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_ID_lookup</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]),</span> <span class="n">sorted_ids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">ids</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_multi_by_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs an incremental removal of the equi-structured ParticleCollections, such to allow</span>

<span class="sd">        a -= b,</span>

<span class="sd">        with &#39;a&#39; and &#39;b&#39; begin the two equi-structured objects (or: &#39;b&#39; being and individual object).</span>
<span class="sd">        This operation is equal to an in-place removal of (an) element(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_same</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseParticleAccessor</span><span class="p">)</span>
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ScipyParticle</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_single_by_object</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Trying to do an incremental removal of an element of type </span><span class="si">%s</span><span class="s2">, which is not supported.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="ParticleCollectionSOA.pop_single_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_single_by_index">[docs]</a>    <span class="k">def</span> <span class="nf">pop_single_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particle at index &#39;index&#39;, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).</span>
<span class="sd">        If index is None, return last item (-1);</span>
<span class="sd">        If index &lt; 0: return from &#39;end&#39; of collection.</span>
<span class="sd">        If index is out of bounds, throws and OutOfRangeException.</span>
<span class="sd">        If Particle cannot be retrieved, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop_single_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.pop_single_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_single_by_ID">[docs]</a>    <span class="k">def</span> <span class="nf">pop_single_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particle with ID &#39;id&#39;, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).</span>
<span class="sd">        If Particle cannot be retrieved (e.g. because the ID is not available), returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop_single_by_ID</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.pop_multi_by_indices"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_multi_by_indices">[docs]</a>    <span class="k">def</span> <span class="nf">pop_multi_by_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particles with the indices registered in &#39;indices&#39;, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).</span>
<span class="sd">        If indices is None -&gt; Particle cannot be retrieved -&gt; Assert-Error and return None</span>
<span class="sd">        If index is None, return last item (-1);</span>
<span class="sd">        If index &lt; 0: return from &#39;end&#39; of collection.</span>
<span class="sd">        If index in &#39;indices&#39; is out of bounds, throws and OutOfRangeException.</span>
<span class="sd">        If Particles cannot be retrieved, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop_multi_by_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.pop_multi_by_IDs"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_multi_by_IDs">[docs]</a>    <span class="k">def</span> <span class="nf">pop_multi_by_IDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particles with the IDs registered in &#39;ids&#39;, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).</span>
<span class="sd">        If Particles cannot be retrieved (e.g. because the IDs are not available), returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop_multi_by_IDs</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_clear_deleted_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This (protected) function physically removes particles from the collection whose status is set to &#39;DELETE&#39;.</span>
<span class="sd">        It is the logical finalisation method of physically deleting particles that have been marked for deletion and</span>
<span class="sd">        that have not otherwise been recovered.</span>
<span class="sd">        This methods in heavily dependent on the actual collection type and should be implemented very specific</span>
<span class="sd">        to the actual data structure, to remove objects &#39;the fastest way possible&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="ParticleCollectionSOA.merge"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function merge two strictly equally-structured ParticleCollections into one. This can be, for example,</span>
<span class="sd">        quite handy to merge two particle subsets that - due to continuous removal - become too small to be effective.</span>

<span class="sd">        On the other hand, this function can also internally merge individual particles that are tagged by status as</span>
<span class="sd">        being &#39;merged&#39; (see the particle status for information on that).</span>

<span class="sd">        In order to distinguish both use cases, we can evaluate the &#39;same_class&#39; parameter. In cases where this is</span>
<span class="sd">        &#39;None&#39;, the merge operation semantically refers to an internal merge of individual particles - otherwise,</span>
<span class="sd">        it performs a 2-collection merge.</span>

<span class="sd">        Comment: the function can be simplified later by pre-evaluating the function parameter and then reference</span>
<span class="sd">        the individual, specific functions for internal- or external merge.</span>

<span class="sd">        The function shall return the merged ParticleCollection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.split"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function splits this collection into two disect equi-structured collections. The reason for it can, for</span>
<span class="sd">        example, be that the set exceeds a pre-defined maximum number of elements, which for performance reasons</span>
<span class="sd">        mandates a split.</span>

<span class="sd">        On the other hand, this function can also internally split individual particles that are tagged byt status as</span>
<span class="sd">        to be &#39;split&#39; (see the particle status for information on that).</span>

<span class="sd">        In order to distinguish both use cases, we can evaluate the &#39;indices&#39; parameter. In cases where this is</span>
<span class="sd">        &#39;None&#39;, the split operation semantically refers to an internal split of individual particles - otherwise,</span>
<span class="sd">        it performs a collection-split.</span>

<span class="sd">        Comment: the function can be simplified later by pre-evaluating the function parameter and then reference</span>
<span class="sd">        the individual, specific functions for element- or collection split.</span>

<span class="sd">        The function shall return the newly created or extended Particle collection, i.e. either the collection that</span>
<span class="sd">        results from a collection split or this very collection, containing the newly-split particles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">__sizeof__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the size in actual bytes required in memory to hold the collection. Ideally and simply,</span>
<span class="sd">        the size is computed as follows:</span>

<span class="sd">        sizeof(self) = len(self) * sizeof(pclass)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="ParticleCollectionSOA.clear"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function physically removes all elements of the collection, yielding an empty collection as result of the</span>
<span class="sd">        operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.cstruct"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.cstruct">[docs]</a>    <span class="k">def</span> <span class="nf">cstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;cstruct&#39; returns the ctypes mapping of the particle data. This depends on the specific structure in question.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">class</span> <span class="nc">CParticles</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
            <span class="c1"># TODO adapt naming of _fields_ in CParticles (code generator) into _variables_</span>
            <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_ctypes_type</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">flatten_dense_data_array</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">data_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
            <span class="n">data_flat</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_ctypes</span><span class="p">(</span><span class="n">data_flat</span><span class="p">)</span>

        <span class="n">cdata</span> <span class="o">=</span> <span class="p">[</span><span class="n">flatten_dense_data_array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">]</span>
        <span class="n">cstruct</span> <span class="o">=</span> <span class="n">CParticles</span><span class="p">(</span><span class="o">*</span><span class="n">cdata</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cstruct</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.toDictionary"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.toDictionary">[docs]</a>    <span class="k">def</span> <span class="nf">toDictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pfile</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">deleted_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert all Particle data from one time step to a python dictionary.</span>
<span class="sd">        :param pfile: ParticleFile object requesting the conversion</span>
<span class="sd">        :param time: Time at which to write ParticleSet</span>
<span class="sd">        :param deleted_only: Flag to write only the deleted Particles</span>
<span class="sd">        returns two dictionaries: one for all variables to be written each outputdt,</span>
<span class="sd">         and one for all variables to be written once</span>

<span class="sd">        This function depends on the specific collection in question and thus needs to be specified in specific</span>
<span class="sd">        derivative classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">data_dict_once</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span> <span class="k">else</span> <span class="n">time</span>

        <span class="n">indices_to_write</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">pfile</span><span class="o">.</span><span class="n">lasttime_written</span> <span class="o">!=</span> <span class="n">time</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="n">pfile</span><span class="o">.</span><span class="n">write_ondelete</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">deleted_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;ParticleSet is empty on writing as array at time </span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">deleted_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">deleted_only</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="ow">and</span> <span class="n">deleted_only</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">indices_to_write</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">],</span>
                                                            <span class="p">[</span><span class="n">OperationCode</span><span class="o">.</span><span class="n">Delete</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">deleted_only</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
                        <span class="n">indices_to_write</span> <span class="o">=</span> <span class="n">deleted_only</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indices_to_write</span> <span class="o">=</span> <span class="n">_to_write_particles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indices_to_write</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">pfile</span><span class="o">.</span><span class="n">var_names</span><span class="p">:</span>
                        <span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">indices_to_write</span><span class="p">]</span>
                    <span class="n">pfile</span><span class="o">.</span><span class="n">maxid_written</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pfile</span><span class="o">.</span><span class="n">maxid_written</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]))</span>

                <span class="n">pset_errs</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">][</span><span class="n">indices_to_write</span><span class="p">]</span> <span class="o">!=</span> <span class="n">OperationCode</span><span class="o">.</span><span class="n">Delete</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="n">indices_to_write</span><span class="p">]),</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="n">indices_to_write</span><span class="p">])))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">pset_errs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning_once</span><span class="p">(</span><span class="s1">&#39;time argument in pfile.write() is </span><span class="si">{}</span><span class="s1">, but particles have time </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="n">pset_errs</span><span class="p">]))</span>

                <span class="c1"># ==== this function should probably move back somewhere into the particle-file instead of the to_dict ==== #</span>
                <span class="k">if</span> <span class="n">time</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pfile</span><span class="o">.</span><span class="n">time_written</span><span class="p">:</span>
                    <span class="n">pfile</span><span class="o">.</span><span class="n">time_written</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pfile</span><span class="o">.</span><span class="n">var_names_once</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">first_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">_to_write_particles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_is_particle_started_yet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">pfile</span><span class="o">.</span><span class="n">written_once</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">first_write</span><span class="p">):</span>
                        <span class="n">data_dict_once</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">first_write</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">pfile</span><span class="o">.</span><span class="n">var_names_once</span><span class="p">:</span>
                            <span class="n">data_dict_once</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">first_write</span><span class="p">]</span>
                        <span class="n">pfile</span><span class="o">.</span><span class="n">written_once</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">first_write</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">deleted_only</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">pfile</span><span class="o">.</span><span class="n">lasttime_written</span> <span class="o">=</span> <span class="n">time</span>

        <span class="k">return</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">data_dict_once</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.toArray"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.toArray">[docs]</a>    <span class="k">def</span> <span class="nf">toArray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function converts (or: transforms; reformats; translates) this collection into an array-like structure</span>
<span class="sd">        (e.g. Python list or numpy nD array) that can be addressed by index. In the common case of &#39;no ID recovery&#39;,</span>
<span class="sd">        the global ID and the index match exactly.</span>

<span class="sd">        While this function may be very convenient for may users, it is STRONGLY DISADVISED to use the function to</span>
<span class="sd">        often, and the performance- and memory overhead malus may be exceed any speed-up one could get from optimised</span>
<span class="sd">        data structures - in fact, for large collections with an implicit-order structure (i.e. ordered lists, sets,</span>
<span class="sd">        trees, etc.), this may be &#39;the most constly&#39; function in any kind of simulation.</span>

<span class="sd">        It can be - though - useful at the final stage of a simulation to dump the results to disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="ParticleCollectionSOA.set_variable_write_status"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionSOA.set_variable_write_status">[docs]</a>    <span class="k">def</span> <span class="nf">set_variable_write_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">write_status</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to set the write status of a Variable</span>
<span class="sd">        :param var: Name of the variable (string)</span>
<span class="sd">        :param status: Write status of the variable (True, False or &#39;once&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">var</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">to_write</span> <span class="o">=</span> <span class="n">write_status</span>
                <span class="n">var_changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">var_changed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Could not change the write status of </span><span class="si">%s</span><span class="s1">, because it is not a Variable name&#39;</span> <span class="o">%</span> <span class="n">var</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ParticleAccessorSOA"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleAccessorSOA">[docs]</a><span class="k">class</span> <span class="nc">ParticleAccessorSOA</span><span class="p">(</span><span class="n">BaseParticleAccessor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper that provides access to particle data in the collection,</span>
<span class="sd">    as if interacting with the particle itself.</span>

<span class="sd">    :param pcoll: ParticleCollection that the represented particle</span>
<span class="sd">                  belongs to.</span>
<span class="sd">    :param index: The index at which the data for the represented</span>
<span class="sd">                  particle is stored in the corresponding data arrays</span>
<span class="sd">                  of the ParticleCollecion.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoll</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the ParticleAccessor to provide access to one</span>
<span class="sd">        specific particle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pcoll</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_dt</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the value of an attribute of the particle.</span>

<span class="sd">        :param name: Name of the requested particle attribute.</span>
<span class="sd">        :return: The value of the particle attribute in the underlying</span>
<span class="sd">                 collection data array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_index&#39;</span><span class="p">,</span> <span class="s1">&#39;_next_dt&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoll</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of an attribute of the particle.</span>

<span class="sd">        :param name: Name of the particle attribute.</span>
<span class="sd">        :param value: Value that will be assigned to the particle</span>
<span class="sd">                      attribute in the underlying collection data array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pcoll&#39;</span><span class="p">,</span> <span class="s1">&#39;_index&#39;</span><span class="p">,</span> <span class="s1">&#39;_next_dt&#39;</span><span class="p">]:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcoll</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">update_next_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_dt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">next_dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pcoll</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_dt</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_dt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_dt</span> <span class="o">=</span> <span class="n">next_dt</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">time_string</span> <span class="o">=</span> <span class="s1">&#39;not_yet_set&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="si">{:f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;P[</span><span class="si">%d</span><span class="s2">](lon=</span><span class="si">%f</span><span class="s2">, lat=</span><span class="si">%f</span><span class="s2">, depth=</span><span class="si">%f</span><span class="s2">, &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoll</span><span class="o">.</span><span class="n">ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">to_write</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]:</span>
                <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%f</span><span class="s2">, &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">str</span> <span class="o">+</span> <span class="s2">&quot;time=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">time_string</span></div>


<div class="viewcode-block" id="ParticleCollectionIteratorSOA"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collectionsoa.ParticleCollectionIteratorSOA">[docs]</a><span class="k">class</span> <span class="nc">ParticleCollectionIteratorSOA</span><span class="p">(</span><span class="n">BaseParticleCollectionIterator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterator for looping over the particles in the ParticleCollection.</span>

<span class="sd">    :param pcoll: ParticleCollection that stores the particles.</span>
<span class="sd">    :param reverse: Flag to indicate reverse iteration (i.e. starting at</span>
<span class="sd">                    the largest index, instead of the smallest).</span>
<span class="sd">    :param subset: Subset of indices to iterate over, this allows the</span>
<span class="sd">                   creation of an iterator that represents part of the</span>
<span class="sd">                   collection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoll</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">subset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Iteration over a subset of particles in the&quot;</span>
                                <span class="s2">&quot; particleset requires a list or numpy array&quot;</span>
                                <span class="s2">&quot; of indices (of type int or np.int32).&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">subset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcoll</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_len</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reverse</span> <span class="o">=</span> <span class="n">reverse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pcoll</span> <span class="o">=</span> <span class="n">pcoll</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_head</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_head</span> <span class="o">=</span> <span class="n">ParticleAccessorSOA</span><span class="p">(</span><span class="n">pcoll</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="o">=</span> <span class="n">ParticleAccessorSOA</span><span class="p">(</span><span class="n">pcoll</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a ParticleAccessor for the next particle in the</span>
<span class="sd">        ParticleSet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_len</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">ParticleAccessorSOA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pcoll</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>

        <span class="c1"># End of Iteration</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dir_str</span> <span class="o">=</span> <span class="s1">&#39;Backward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reverse</span> <span class="k">else</span> <span class="s1">&#39;Forward&#39;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> iteration at index </span><span class="si">%s</span><span class="s2"> of </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dir_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_len</span><span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/parcelslogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Parcels 2.2.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">parcels.particlesets.collectionsoa</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Michael Lange and Erik van Sebille.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>