

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>parcels.particlesets.collections &#8212; Parcels 2.2.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />

    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-96368922-1', 'auto');
  ga('send', 'pageview');
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Parcels 2.2.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">parcels.particlesets.collections</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for parcels.particlesets.collections</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">.iterators</span> <span class="kn">import</span> <span class="n">BaseParticleAccessor</span>
<span class="kn">from</span> <span class="nn">parcels.particle</span> <span class="kn">import</span> <span class="n">ScipyParticle</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Author: Dr. Christian Kehl</span>
<span class="sd">github relation: #913 (particleset_class_hierarchy)</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Collection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection">[docs]</a><span class="k">class</span> <span class="nc">Collection</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="n">_ncount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collection - Constructor</span>
<span class="sd">        Initializes a collection by pre-allocating memory (where needed), initialising indexing structures</span>
<span class="sd">        (where needed), initialising iterators and preparing the C-JIT-glue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collection - Destructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ncount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function represents a forward-iteration over the collection, the the sense it is called</span>

<span class="sd">        for item in collection_object:</span>
<span class="sd">            &lt;do something&gt;</span>

<span class="sd">        In this sense, this function (if actually being implemented as such - which is not necessarily the sensible case</span>
<span class="sd">        for every collection) would here return an iterator (either re-created or persistent; preferably created anew).</span>

<span class="sd">        For iterating over a collection, it is possible to &#39;iterate&#39; over an iterator, such that:</span>

<span class="sd">        collection_iterator = collection_object.iterator()</span>
<span class="sd">        for item in collection_iterator:</span>
<span class="sd">            &lt;do something&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Collection.iterator"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.iterator">[docs]</a>    <span class="k">def</span> <span class="nf">iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is an explicit object-return of a forward-iterator over this collection. If this iterator is</span>
<span class="sd">        persistent or re-created upon call depends on the specific implementation of the &#39;__iter__&#39; function.</span>

<span class="sd">        This function is an explicit forward to the Collection::__iter__() member function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function represents a backward-iteration over the collection, the the sense it is called</span>

<span class="sd">        for item in reversed(collection_object):</span>
<span class="sd">            &lt;do something&gt;</span>

<span class="sd">        In this sense, this function (if actually being implemented as such - which is not necessarily the sensible case</span>
<span class="sd">        for every collection) would here return a reverse-iterator (either re-created or persistent; preferably created</span>
<span class="sd">        anew).</span>

<span class="sd">        For iterating over a collection, it is possible to &#39;iterate&#39; over an iterator, such that:</span>

<span class="sd">        collection_iterator = collection_object.reverse_iterator()</span>
<span class="sd">        for item in collection_iterator:</span>
<span class="sd">            &lt;do something&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Collection.reverse_iterator"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.reverse_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">reverse_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is an explicit object-return of a backward-iterator over this collection. If this iterator is</span>
<span class="sd">        persistent or re-created upon call depends on the specific implementation of the &#39;__reversed__&#39; function.</span>

<span class="sd">        This function is an explicit forward to the Collection::__reversed__() member function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__reversed__</span><span class="p">()</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should return an item [accessor, as reference] at a certain &#39;position&#39;, in the sense of</span>

<span class="sd">        item_ref = collection_object[&lt;some_indexing_concept&gt;]</span>

<span class="sd">        The actual return and implementation of this will depend on the specific collection at hand. Ideally, this</span>
<span class="sd">        function demands as &#39;key&#39; an object that matches the most-performant access method, i.e.</span>

<span class="sd">        ordered lists, sets, trees -&gt; getitem(key = [int64, uint64] id) -&gt; operates on a list-iterator</span>
<span class="sd">        arrays, vectors, dense arrays &amp; matrices -&gt; getitem(key = [int, int32] index) -&gt; operates on an index-managed iterator</span>

<span class="sd">        Out of performance reasons, there should be no alternative getitem with other positional arguments than the</span>
<span class="sd">        optimal one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Collection.get"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a generic super-method to get one- or multiple Particles (via their object, their ParticleAccessor,</span>
<span class="sd">        their ID or their index) from the collection. Ideally, it just discerns between the types of the &#39;other&#39;</span>
<span class="sd">        parameter, and then forwards the call to the related specific function.</span>

<span class="sd">        Comment/Annotation:</span>
<span class="sd">        Not all arguments have a sensible use-case in every datastructure, so some concrete classes may not implementat</span>
<span class="sd">        all of them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_same</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParticleCollection</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
            <span class="c1"># multi-get routines - hard to discern at this point</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multi_by_indices</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multi_by_IDs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multi_by_indices</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multi_by_IDs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_by_index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_by_ID</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_by_object</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_single_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_single_by_index">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_single_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets a (particle) object from the collection based on its index within the collection. For</span>
<span class="sd">        collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a</span>
<span class="sd">        translation of the index into the specific object reference in the collection - or (if unavoidable) the</span>
<span class="sd">        translation of the collection from a none-indexable, none-random-access structure into an indexable structure.</span>
<span class="sd">        In cases where a get-by-index would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        get function, e.g. get-by-ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to get a particle by index, but index </span><span class="si">{}</span><span class="s2"> is not a 32-bit integer - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_single_by_object"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_single_by_object">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_single_by_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets a (particle) object from the collection based on its actual object. For collections that</span>
<span class="sd">        are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function</span>
<span class="sd">        would involve a parsing of the whole list and translation of the object into an index in the collection - which</span>
<span class="sd">        results in a significant performance malus.</span>
<span class="sd">        In cases where a get-by-object would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        get function, e.g. get-by-index or get-by-ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">,</span> <span class="n">BaseParticleAccessor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">,</span> <span class="n">ScipyParticle</span><span class="p">))</span></div>

<div class="viewcode-block" id="Collection.get_single_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_single_by_ID">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_single_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets a (particle) object from the collection based on the object&#39;s ID. For some collections,</span>
<span class="sd">        this operation may involve a parsing of the whole list and translation of the object&#39;s ID into an index  or an</span>
<span class="sd">        object reference in the collection - which results in a significant performance malus.</span>
<span class="sd">        In cases where a get-by-ID would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        get function, e.g. get-by-index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to get a particle by ID, but ID </span><span class="si">{}</span><span class="s2"> is not a 64-bit (signed or unsigned) iteger - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_same"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_same">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection that are themselves stored in another object of an equi-</span>
<span class="sd">        structured ParticleCollection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">same_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to get another </span><span class="si">{}</span><span class="s2"> from this one, but the other one is None - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_collection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_collection">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcollection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection that are themselves stored in a ParticleCollection, which</span>
<span class="sd">        is differently structured than this one. That means the other-collection has to be re-formatted first in an</span>
<span class="sd">        intermediary format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">pcollection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to get another particle collection from this one, but the other one is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pcollection</span><span class="p">,</span> <span class="n">ParticleCollection</span><span class="p">),</span> <span class="s2">&quot;Trying to get another particle collection from this one, but the other is not of the type of &#39;ParticleCollection&#39; - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">pcollection</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_multi_by_PyCollection_Particles"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_multi_by_PyCollection_Particles">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pycollectionp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection, which are themselves in common Python collections, such as</span>
<span class="sd">        lists, dicts and numpy structures. We can either directly get the referred Particle instances (for internally-</span>
<span class="sd">        ordered collections, e.g. ordered lists, sets, trees) or we may need to parse each instance for its index (for</span>
<span class="sd">        random-access structures), which results in a considerable performance malus.</span>

<span class="sd">        For collections where get-by-object incurs a performance malus, it is advisable to multi-get particles</span>
<span class="sd">        by indices or IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">pycollectionp</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to get a collection of Particles, but their container is not a valid Python-collection - invalid operation.&quot;</span></div>

<div class="viewcode-block" id="Collection.get_multi_by_indices"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_multi_by_indices">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_multi_by_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection based on their indices. This works best for random-access</span>
<span class="sd">        collections (e.g. numpy&#39;s ndarrays, dense matrices and dense arrays), whereas internally ordered collections</span>
<span class="sd">        shall rather use a get-via-object-reference strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to get particles by their collection indices, but the index list is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to get particles by their IDs, but the ID container is not a valid Python-collection - invalid operation.&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to get particles by their index, but the index type in the Python collection is not a 32-bit integer - invalid operation.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to get particles by their index, but the index type in the Python collection is not a 32-bit integer - invalid operation.&quot;</span></div>

<div class="viewcode-block" id="Collection.get_multi_by_IDs"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.get_multi_by_IDs">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_multi_by_IDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets particles from this collection based on their IDs. For collections where this removal</span>
<span class="sd">        strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a get-</span>
<span class="sd">        by-objects or get-by-indices scheme.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to get particles by their IDs, but the ID list is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to get particles by their IDs, but the ID container is not a valid Python-collection - invalid operation.&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to get particles by their IDs, but the ID type in the Python collection is not a 64-bit (signed or unsigned) integer - invalid operation.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to get particles by their IDs, but the ID type in the Python collection is not a 64-bit (signed or unsigned) integer - invalid operation.&quot;</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a generic super-method to add one- or multiple objects to this collection. Ideally, it just discerns</span>
<span class="sd">        between the types of the &#39;other&#39; parameter, and then forwards the call to the related specific function.</span>

<span class="sd">        Comment/Annotation:</span>
<span class="sd">        Functions for adding multiple objects are more specialised than just a for-each loop of single-item addition,</span>
<span class="sd">        because certain data structures can add multiple objects in-bulk faster with specialised function than making a</span>
<span class="sd">        roundtrip per-item add operation. Because of the sheer size of those containers and the resulting</span>
<span class="sd">        performance demands, we need to make use of those specialised &#39;add&#39; functions, where available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_same</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParticleCollection</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_single</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Collection.add_collection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.add_collection">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">add_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcollection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds another, differently structured ParticleCollection to this collection. This is done by, for example,</span>
<span class="sd">        appending/adding the items of the other collection to this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">pcollection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to add another particle collection to this one, but the other one is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pcollection</span><span class="p">,</span> <span class="n">ParticleCollection</span><span class="p">),</span> <span class="s2">&quot;Trying to add another particle collection to this one, but the other is not of the type of &#39;ParticleCollection&#39; - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">pcollection</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.add_single"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.add_single">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">add_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adding a single Particle to the collection - either as a &#39;Particle; object in parcels itself, or</span>
<span class="sd">        via its ParticleAccessor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">,</span> <span class="n">BaseParticleAccessor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">,</span> <span class="n">ScipyParticle</span><span class="p">))</span></div>

<div class="viewcode-block" id="Collection.add_same"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.add_same">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">add_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds another, equi-structured ParticleCollection to this collection. This is done by concatenating</span>
<span class="sd">        both collections. The fact that they are of the same ParticleCollection&#39;s derivative simplifies</span>
<span class="sd">        parsing and concatenation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">same_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to add another </span><span class="si">{}</span><span class="s2"> to this one, but the other one is None - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs an incremental addition of the equi-structured ParticleCollections, such to allow</span>

<span class="sd">        a += b,</span>

<span class="sd">        with &#39;a&#39; and &#39;b&#39; begin the two equi-structured objects (or: &#39;b&#39; being and individual object).</span>
<span class="sd">        This operation is equal to an in-place addition of (an) element(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">same_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;Trying to increment-add collection of type </span><span class="si">{}</span><span class="s2"> into collection of type </span><span class="si">{}</span><span class="s2"> - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">same_class</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Collection.insert"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.insert">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function allows to &#39;insert&#39; a Particle (as object or via its accessor) into this collection. This method</span>
<span class="sd">        needs to be specified to each collection individually. Some collections (e.g. unordered list) allow to define</span>
<span class="sd">        the index where the object is to be inserted. Some collections can optionally insert an object at a specific</span>
<span class="sd">        position - at a significant speed- and memory malus cost (e.g. vectors, arrays, dense matrices). Some</span>
<span class="sd">        collections that manage a specified indexing order internally (e.g. ordered lists, sets, trees), and thus</span>
<span class="sd">        have no use for an &#39;index&#39; parameter. For those collections with an internally-enforced order, the function</span>
<span class="sd">        mapping equates to:</span>

<span class="sd">        insert(obj) -&gt; add_single(obj)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Collection.push"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.push">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function pushes a Particle (as object or via its accessor) to the end of a collection (&#39;end&#39; definition</span>
<span class="sd">        depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,</span>
<span class="sd">        sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the</span>
<span class="sd">        end). For the collections, the function mapping equates to:</span>

<span class="sd">        int32 push(particle_obj) -&gt; add_single(particle_obj); return -1;</span>

<span class="sd">        This function further returns the index, at which position the Particle has been inserted. By definition,</span>
<span class="sd">        the index is positive, thus: a return of &#39;-1&#39; indicates push failure, NOT the last position in the collection.</span>
<span class="sd">        Furthermore, collections that do not work on an index-preserving manner also return &#39;-1&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Collection.append"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.append">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function appends a Particle (as object or via its accessor) to the end of a collection (&#39;end&#39; definition</span>
<span class="sd">        depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,</span>
<span class="sd">        sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the</span>
<span class="sd">        end). For the collections, the function mapping equates to:</span>

<span class="sd">        append(particle_obj) -&gt; add_single(particle_obj)</span>

<span class="sd">        The function - in contrast to &#39;push&#39; - does not return the index of the inserted object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the high-performance method to delete a specific object from this collection.</span>
<span class="sd">        As the most-performant way depends on the specific collection in question, the function is abstract.</span>

<span class="sd">        Highlight for the specific implementation:</span>
<span class="sd">        The &#39;key&#39; parameter should still be evaluated for being a single or a multi-entry delete, and needs to check</span>
<span class="sd">        that it received the correct type of &#39;indexing&#39; argument (i.e. index, id or iterator).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Collection.delete"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.delete">[docs]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the generic super-method to indicate obejct deletion of a specific object from this collection.</span>

<span class="sd">        Comment/Annotation:</span>
<span class="sd">        Functions for deleting multiple objects are more specialised than just a for-each loop of single-item deletion,</span>
<span class="sd">        because certain data structures can delete multiple objects in-bulk faster with specialised function than making a</span>
<span class="sd">        roundtrip per-item delete operation. Because of the sheer size of those containers and the resulting</span>
<span class="sd">        performance demands, we need to make use of those specialised &#39;del&#39; functions, where available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_by_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_by_ID</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.delete_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.delete_by_index">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">delete_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method deletes a particle from the  the collection based on its index. It does not return the deleted item.</span>
<span class="sd">        Semantically, the function appears similar to the &#39;remove&#39; operation. That said, the function in OceanParcels -</span>
<span class="sd">        instead of directly deleting the particle - just raises the &#39;deleted&#39; status flag for the indexed particle.</span>
<span class="sd">        In result, the particle still remains in the collection. The functional interpretation of the &#39;deleted&#39; status</span>
<span class="sd">        is handled by &#39;recovery&#39; dictionary during simulation execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to delete a particle by index, but index </span><span class="si">{}</span><span class="s2"> is not a 32-bit integer - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.delete_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.delete_by_ID">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">delete_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method deletes a particle from the  the collection based on its ID. It does not return the deleted item.</span>
<span class="sd">        Semantically, the function appears similar to the &#39;remove&#39; operation. That said, the function in OceanParcels -</span>
<span class="sd">        instead of directly deleting the particle - just raises the &#39;deleted&#39; status flag for the indexed particle.</span>
<span class="sd">        In result, the particle still remains in the collection. The functional interpretation of the &#39;deleted&#39; status</span>
<span class="sd">        is handled by &#39;recovery&#39; dictionary during simulation execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to delete a particle by ID, but ID </span><span class="si">{}</span><span class="s2"> is not a 64-bit (signed or unsigned) integer - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a high-performance method to remove an object (via their object, their ParticleAccessor,</span>
<span class="sd">        their ID or their index) from the collection. As the function applies to collections itself, it maps directly</span>
<span class="sd">        to:</span>

<span class="sd">        a-b -&gt; a.remove(b)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_same</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParticleCollection</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_collection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Collection.remove"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a generic super-method to remove one- or multiple Particles (via their object, their ParticleAccessor,</span>
<span class="sd">        their ID or their index) from the collection. Ideally, it just discerns between the types of the &#39;other&#39;</span>
<span class="sd">        parameter, and then forwards the call to the related specific function.</span>

<span class="sd">        Comment/Annotation:</span>
<span class="sd">        Functions for removing multiple objects are more specialised than just a for-each loop of single-item removal,</span>
<span class="sd">        because certain data structures can remove multiple objects faster with specialised function than making a</span>
<span class="sd">        roundtrip per-item check-and-remove operation. Because of the sheer size of those containers and the resulting</span>
<span class="sd">        performance demands, we need to make use of those specialised &#39;remove&#39; functions, where available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_same</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParticleCollection</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_collection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
            <span class="c1"># multi-removal routines - hard to discern at this point</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_multi_by_indices</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_multi_by_IDs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_multi_by_indices</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_multi_by_IDs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_single_by_index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_single_by_ID</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_single_by_object</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.remove_single_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_single_by_index">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_single_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes a (particle) object from the collection based on its index within the collection. For</span>
<span class="sd">        collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a</span>
<span class="sd">        translation of the index into the specific object reference in the collection - or (if unavoidable) the</span>
<span class="sd">        translation of the collection from a none-indexable, none-random-access structure into an indexable structure,</span>
<span class="sd">        and then perform the removal.</span>
<span class="sd">        In cases where a removal-by-index would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        removal functions, e.g. remove-by-object or remove-by-ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to remove a particle by index, but index </span><span class="si">{}</span><span class="s2"> is not a 32-bit integer - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.remove_single_by_object"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_single_by_object">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_single_by_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes a (particle) object from the collection based on its actual object. For collections that</span>
<span class="sd">        are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function</span>
<span class="sd">        would involves a parsing of the whole list and translation of the object into an index in the collection to</span>
<span class="sd">        perform the removal - which results in a significant performance malus.</span>
<span class="sd">        In cases where a removal-by-object would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        removal functions, e.g. remove-by-index or remove-by-ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">,</span> <span class="n">BaseParticleAccessor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">particle_obj</span><span class="p">,</span> <span class="n">ScipyParticle</span><span class="p">))</span></div>

<div class="viewcode-block" id="Collection.remove_single_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_single_by_ID">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_single_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes a (particle) object from the collection based on the object&#39;s ID. For some collections,</span>
<span class="sd">        this operation may involve a parsing of the whole list and translation of the object&#39;s ID into an index  or an</span>
<span class="sd">        object reference in the collection in order to perform the removal - which results in a significant performance</span>
<span class="sd">        malus.</span>
<span class="sd">        In cases where a removal-by-ID would result in a performance malus, it is highly-advisable to use a different</span>
<span class="sd">        removal functions, e.g. remove-by-object or remove-by-index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to remove a particle by ID, but ID </span><span class="si">{}</span><span class="s2"> is not a 64-bit (signed or unsigned) iteger - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.remove_same"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_same">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection that are themselves stored in another object of an equi-</span>
<span class="sd">        structured ParticleCollection. As the structures of both collections are the same, a more efficient M-in-N</span>
<span class="sd">        removal can be applied without an in-between reformatting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">same_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to remove another </span><span class="si">{}</span><span class="s2"> from this one, but the other one is None - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">same_class</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.remove_collection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_collection">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcollection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection that are themselves stored in a ParticleCollection, which</span>
<span class="sd">        is differently structured than this one. Tht means the removal first requires the removal-collection to be re-</span>
<span class="sd">        formatted in an intermediary format, before executing the removal.</span>
<span class="sd">        That said, this method should still be at least as efficient as a removal via common Python collections (i.e.</span>
<span class="sd">        lists, dicts, numpy&#39;s nD arrays &amp; dense arrays). Despite this, due to the reformatting, in some cases it may</span>
<span class="sd">        be more efficient to remove items then rather by IDs oder indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">pcollection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to remove another particle collection from this one, but the other one is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pcollection</span><span class="p">,</span> <span class="n">ParticleCollection</span><span class="p">),</span> <span class="s2">&quot;Trying to remove another particle collection from this one, but the other is not of the type of &#39;ParticleCollection&#39; - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">pcollection</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.remove_multi_by_PyCollection_Particles"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_multi_by_PyCollection_Particles">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_multi_by_PyCollection_Particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pycollectionp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection, which are themselves in common Python collections, such as</span>
<span class="sd">        lists, dicts and numpy structures. In order to perform the removal, we can either directly remove the referred</span>
<span class="sd">        Particle instances (for internally-ordered collections, e.g. ordered lists, sets, trees) or we may need to parse</span>
<span class="sd">        each instance for its index (for random-access structures), which results in a considerable performance malus.</span>

<span class="sd">        For collections where removal-by-object incurs a performance malus, it is advisable to multi-remove particles</span>
<span class="sd">        by indices or IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">pycollectionp</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to remove a collection of Particles, but their container is not a valid Python-collection - invalid operation.&quot;</span></div>

<div class="viewcode-block" id="Collection.remove_multi_by_indices"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_multi_by_indices">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_multi_by_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection based on their indices. This works best for random-access</span>
<span class="sd">        collections (e.g. numpy&#39;s ndarrays, dense matrices and dense arrays), whereas internally ordered collections</span>
<span class="sd">        shall rather use a removal-via-object-reference strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to remove particles by their collection indices, but the index list is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to remove particles by their indices, but the index container is not a valid Python-collection - invalid operation.&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to remove particles by their index, but the index type in the Python collection is not a 32-bit integer - invalid operation.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to remove particles by their index, but the index type in the Python collection is not a 32-bit integer - invalid operation.&quot;</span></div>

<div class="viewcode-block" id="Collection.remove_multi_by_IDs"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.remove_multi_by_IDs">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remove_multi_by_IDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function removes particles from this collection based on their IDs. For collections where this removal</span>
<span class="sd">        strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a removal-</span>
<span class="sd">        by-objects or removal-by-indices scheme.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to remove particles by their IDs, but the ID list is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to remove particles by their IDs, but the ID container is not a valid Python-collection - invalid operation.&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to remove particles by their IDs, but the ID type in the Python collection is not a 64-bit (signed or unsigned) integer - invalid operation.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to remove particles by their IDs, but the ID type in the Python collection is not a 64-bit (signed or unsigned) integer - invalid operation.&quot;</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs an incremental removal of the equi-structured ParticleCollections, such to allow</span>

<span class="sd">        a -= b,</span>

<span class="sd">        with &#39;a&#39; and &#39;b&#39; begin the two equi-structured objects (or: &#39;b&#39; being and individual object).</span>
<span class="sd">        This operation is equal to an in-place removal of (an) element(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Collection.pop"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function pops a Particle (as object or via its accessor) from a collection.</span>

<span class="sd">        This function removes the particle and then returns it.</span>

<span class="sd">        Comment/Annotation:</span>
<span class="sd">        Functions for popping multiple objects are more specialised than just a for-each loop of single-item pop,</span>
<span class="sd">        because certain data structures can pop multiple objects faster with specialised function than making a</span>
<span class="sd">        roundtrip per-item check-and-pop operation. Because of the sheer size of those containers and the resulting</span>
<span class="sd">        performance demands, we need to make use of those specialised &#39;pop&#39; functions, where available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_single_by_index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_single_by_ID</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
            <span class="c1"># multi-removal routines - hard to discern at this point</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_multi_by_indices</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_multi_by_IDs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_multi_by_indices</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_multi_by_IDs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.pop_single_by_index"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.pop_single_by_index">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pop_single_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particle at index &#39;index&#39;, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).</span>
<span class="sd">        If index is None, return last item (-1);</span>
<span class="sd">        If index &lt; 0: return from &#39;end&#39; of collection.</span>
<span class="sd">        If index is out of bounds, throws and OutOfRangeException.</span>
<span class="sd">        If Particle cannot be retrieved, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to pop a particle by index, but index </span><span class="si">{}</span><span class="s2"> is not a 32-bit integer - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Collection.pop_single_by_ID"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.pop_single_by_ID">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pop_single_by_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particle with ID &#39;id&#39;, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).</span>
<span class="sd">        If Particle cannot be retrieved (e.g. because the ID is not available), returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to pop a particle by ID, but ID </span><span class="si">{}</span><span class="s2"> is not a 64-bit (signed or unsigned) iteger - invalid operation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Collection.pop_multi_by_indices"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.pop_multi_by_indices">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pop_multi_by_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particles with the indices registered in &#39;indices&#39;, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).</span>
<span class="sd">        If indices is None -&gt; Particle cannot be retrieved -&gt; Assert-Error and return None</span>
<span class="sd">        If index is None, return last item (-1);</span>
<span class="sd">        If index &lt; 0: return from &#39;end&#39; of collection.</span>
<span class="sd">        If index in &#39;indices&#39; is out of bounds, throws and OutOfRangeException.</span>
<span class="sd">        If Particles cannot be retrieved, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to pop particles by their collection indices, but the index list is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to pop particles by their IDs, but the ID container is not a valid Python-collection - invalid operation.&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to pop particles by their index, but the index type in the Python collection is not a 32-bit integer - invalid operation.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">],</span> <span class="s2">&quot;Trying to pop particles by their index, but the index type in the Python collection is not a 32-bit integer - invalid operation.&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Collection.pop_multi_by_IDs"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.pop_multi_by_IDs">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pop_multi_by_IDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for Particles with the IDs registered in &#39;ids&#39;, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).</span>
<span class="sd">        If Particles cannot be retrieved (e.g. because the IDs are not available), returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Trying to pop particles by their IDs, but the ID list is None - invalid operation.&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="s2">&quot;Trying to pop particles by their IDs, but the ID container is not a valid Python-collection - invalid operation.&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to pop particles by their IDs, but the ID type in the Python collection is not a 64-bit (signed or unsigned) integer - invalid operation.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">],</span> <span class="s2">&quot;Trying to pop particles by their IDs, but the ID type in the Python collection is not a 64-bit (signed or unsigned) integer - invalid operation.&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_clear_deleted_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This (protected) function physically removes particles from the collection whose status is set to &#39;DELETE&#39;.</span>
<span class="sd">        It is the logical finalisation method of physically deleting particles that have been marked for deletion and</span>
<span class="sd">        that have not otherwise been recovered.</span>
<span class="sd">        This methods in heavily dependent on the actual collection type and should be implemented very specific</span>
<span class="sd">        to the actual data structure, to remove objects &#39;the fastest way possible&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Collection.merge"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.merge">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function merge two strictly equally-structured ParticleCollections into one. This can be, for example,</span>
<span class="sd">        quite handy to merge two particle subsets that - due to continuous removal - become too small to be effective.</span>

<span class="sd">        On the other hand, this function can also internally merge individual particles that are tagged by status as</span>
<span class="sd">        being &#39;merged&#39; (see the particle status for information on that).</span>

<span class="sd">        In order to distinguish both use cases, we can evaluate the &#39;same_class&#39; parameter. In cases where this is</span>
<span class="sd">        &#39;None&#39;, the merge operation semantically refers to an internal merge of individual particles - otherwise,</span>
<span class="sd">        it performs a 2-collection merge.</span>

<span class="sd">        Comment: the function can be simplified later by pre-evaluating the function parameter and then reference</span>
<span class="sd">        the individual, specific functions for internal- or external merge.</span>

<span class="sd">        The function shall return the merged ParticleCollection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Collection.split"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.split">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function splits this collection into two disect equi-structured collections. The reason for it can, for</span>
<span class="sd">        example, be that the set exceeds a pre-defined maximum number of elements, which for performance reasons</span>
<span class="sd">        mandates a split.</span>

<span class="sd">        On the other hand, this function can also internally split individual particles that are tagged byt status as</span>
<span class="sd">        to be &#39;split&#39; (see the particle status for information on that).</span>

<span class="sd">        In order to distinguish both use cases, we can evaluate the &#39;indices&#39; parameter. In cases where this is</span>
<span class="sd">        &#39;None&#39;, the split operation semantically refers to an internal split of individual particles - otherwise,</span>
<span class="sd">        it performs a collection-split.</span>

<span class="sd">        Comment: the function can be simplified later by pre-evaluating the function parameter and then reference</span>
<span class="sd">        the individual, specific functions for element- or collection split.</span>

<span class="sd">        The function shall return the newly created or extended Particle collection, i.e. either the collection that</span>
<span class="sd">        results from a collection split or this very collection, containing the newly-split particles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns and informative string about the collection (i.e. the type of collection) and a summary</span>
<span class="sd">        of its internal, distinct values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;ParticleCollection - N: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span><span class="p">)</span>

<div class="viewcode-block" id="Collection.toArray"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.toArray">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">toArray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function converts (or: transforms; reformats; translates) this collection into an array-like structure</span>
<span class="sd">        (e.g. Python list or numpy nD array) that can be addressed by index. In the common case of &#39;no ID recovery&#39;,</span>
<span class="sd">        the global ID and the index match exactly.</span>

<span class="sd">        While this function may be very convenient for may users, it is STRONGLY DISADVISED to use the function to</span>
<span class="sd">        often, and the performance- and memory overhead malus may be exceed any speed-up one could get from optimised</span>
<span class="sd">        data structures - in fact, for large collections with an implicit-order structure (i.e. ordered lists, sets,</span>
<span class="sd">        trees, etc.), this may be &#39;the most constly&#39; function in any kind of simulation.</span>

<span class="sd">        It can be - though - useful at the final stage of a simulation to dump the results to disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the length, in terms of &#39;number of elements, of a collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__sizeof__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the size in actual bytes required in memory to hold the collection. Ideally and simply,</span>
<span class="sd">        the size is computed as follows:</span>

<span class="sd">        sizeof(self) = len(self) * sizeof(pclass)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Collection.empty"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.empty">[docs]</a>    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function retuns a boolean value, expressing if a collection is emoty (i.e. does not [anymore] contain any</span>
<span class="sd">        elements) or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.clear"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.Collection.clear">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function physically removes all elements of the collection, yielding an empty collection as result of the</span>
<span class="sd">        operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="ParticleCollection"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.ParticleCollection">[docs]</a><span class="k">class</span> <span class="nc">ParticleCollection</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="n">_pu_indicators</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># formerly: partitions</span>
    <span class="n">_pu_centers</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_pclass</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_ptype</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_latlondepth_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># formerly: particle_data</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ParticleCollection - Constructor</span>
<span class="sd">        Initializes a particle collection by pre-allocating memory (where needed), initialising indexing structures</span>
<span class="sd">        (where needed), initialising iterators (if maintaining a persistent iterator) and preparing the C-JIT-glue.</span>

<span class="sd">        Furthermore, initialising the PU distribution and its distribution metrics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ncount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># formerly: partitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pu_centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pclass</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latlondepth_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># formerly: particle_data</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParticleCollection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ParticleCollection - Destructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pu_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The &#39;pu_indicator&#39; is an [array or dictionary]-of-indicators, where each indicator entry tells per item</span>
<span class="sd">        (i.e. particle) in the collection to which processing unit (PU) in a parallelised setup it belongs to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pu_indicators</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pu_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The &#39;pu_centers&quot; is an array of 2D/3D vectors storing the center of each cluster-of-particle partion that</span>
<span class="sd">        is handled by the respective PU. Storing the centers allows us to only run the initial kMeans segmentation</span>
<span class="sd">        once and then, on later particle additions, just (i) makes a closest-distance calculation, (ii) attaches the</span>
<span class="sd">        new particle to the closest cluster and (iii) updates the new cluster center. The last part may require at some</span>
<span class="sd">        point to merge overlaying clusters and them split them again in equi-sized partions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pu_centers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pclass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;pclass&#39; stores the actual class type of the particles allocated and managed in this collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pclass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ptype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;ptype&#39; returns an instance of the particular type of class &#39;ParticleType&#39; of the particle class of the particles</span>
<span class="sd">        in this collection.</span>

<span class="sd">        basically:</span>
<span class="sd">        pytpe -&gt; pclass().getPType()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lonlatdepth_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;lonlatdepth_dtype&#39; stores the numeric data type that is used to represent the lon, lat and depth of a particle.</span>
<span class="sd">        This can be either &#39;float32&#39; (default) or &#39;float64&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lonlatdepth_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;data&#39; is a reference to the actual barebone-storage of the particle data, and thus depends directly on the</span>
<span class="sd">        specific collection in question.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">particle_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;particle_data&#39; is a reference to the actual barebone-storage of the particle data, and thus depends directly on the</span>
<span class="sd">        specific collection in question. This property is just available for convenience and backward-compatibility, and</span>
<span class="sd">        this returns the same as &#39;data&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

<div class="viewcode-block" id="ParticleCollection.cstruct"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.ParticleCollection.cstruct">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">cstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;cstruct&#39; returns the ctypes mapping of the particle data. This depends on the specific structure in question.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access a single property of all particles.</span>
<span class="sd">        NOTE: This is a fallback implementation, and it is NOT efficient.</span>
<span class="sd">        Specific datastructures may implement a more efficient variant.</span>

<span class="sd">        :param name: name of the property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptype</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="ParticleCollection.toDictionary"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.ParticleCollection.toDictionary">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">toDictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert all Particle data from one time step to a python dictionary.</span>
<span class="sd">        :param pfile: ParticleFile object requesting the conversion</span>
<span class="sd">        :param time: Time at which to write ParticleSet</span>
<span class="sd">        :param deleted_only: Flag to write only the deleted Particles</span>
<span class="sd">        returns two dictionaries: one for all variables to be written each outputdt,</span>
<span class="sd">         and one for all variables to be written once</span>

<span class="sd">         This function depends on the specific collection in question and thus needs to be specified in specific</span>
<span class="sd">         derivatives classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="ParticleCollection.set_variable_write_status"><a class="viewcode-back" href="../../../index.html#parcels.particlesets.collections.ParticleCollection.set_variable_write_status">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">set_variable_write_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">write_status</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to set the write status of a Variable</span>
<span class="sd">        :param var: Name of the variable (string)</span>
<span class="sd">        :param status: Write status of the variable (True, False or &#39;once&#39;)</span>

<span class="sd">         This function depends on the specific collection in question and thus needs to be specified in specific</span>
<span class="sd">         derivatives classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/parcelslogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Parcels 2.2.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">parcels.particlesets.collections</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Michael Lange and Erik van Sebille.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>