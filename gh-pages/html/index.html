

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parcels documentation &#8212; Parcels 2.2.1 documentation</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />

    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-96368922-1', 'auto');
  ga('send', 'pageview');
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Parcels 2.2.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Parcels documentation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="parcels-documentation">
<h1>Parcels documentation<a class="headerlink" href="#parcels-documentation" title="Permalink to this headline">¶</a></h1>
<p>Welcome to the documentation of parcels. This page provides detailed documentation for each method, class and function.
The documentation corresponds to the latest conda release, for newer documentation see the docstrings in the code.</p>
<p>See <a class="reference external" href="http://www.oceanparcels.org">http://www.oceanparcels.org</a> for general information on the Parcels project, including how to install and use.</p>
<div class="section" id="module-parcels.particlesets.particlesetsoa">
<span id="parcels-particleset-module"></span><h2>parcels.particleset module<a class="headerlink" href="#module-parcels.particlesets.particlesetsoa" title="Permalink to this headline">¶</a></h2>
<dl class="py attribute">
<dt id="parcels.particlesets.particlesetsoa.ParticleSet">
<code class="sig-prename descclassname">parcels.particlesets.particlesetsoa.</code><code class="sig-name descname">ParticleSet</code><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSet" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA" title="parcels.particlesets.particlesetsoa.ParticleSetSOA"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlesets.particlesetsoa.ParticleSetSOA</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.particlesetsoa.</code><code class="sig-name descname">ParticleSetSOA</code><span class="sig-paren">(</span><em class="sig-param">fieldset=None</em>, <em class="sig-param">pclass=&lt;class 'parcels.particle.JITParticle'&gt;</em>, <em class="sig-param">lon=None</em>, <em class="sig-param">lat=None</em>, <em class="sig-param">depth=None</em>, <em class="sig-param">time=None</em>, <em class="sig-param">repeatdt=None</em>, <em class="sig-param">lonlatdepth_dtype=None</em>, <em class="sig-param">pid_orig=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.particlesets.baseparticleset.BaseParticleSet" title="parcels.particlesets.baseparticleset.BaseParticleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlesets.baseparticleset.BaseParticleSet</span></code></a></p>
<p>Container class for storing particle and executing kernel over them.</p>
<p>Please note that this currently only supports fixed size particle sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object from which to sample velocity.
While fieldset=None is supported, this will throw a warning as it breaks most Parcels functionality</p></li>
<li><p><strong>pclass</strong> – Optional <a class="reference internal" href="#parcels.particle.JITParticle" title="parcels.particle.JITParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.JITParticle</span></code></a> or
<a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a> object that defines custom particle</p></li>
<li><p><strong>lon</strong> – List of initial longitude values for particles</p></li>
<li><p><strong>lat</strong> – List of initial latitude values for particles</p></li>
<li><p><strong>depth</strong> – Optional list of initial depth values for particles. Default is 0m</p></li>
<li><p><strong>time</strong> – Optional list of initial time values for particles. Default is fieldset.U.grid.time[0]</p></li>
<li><p><strong>repeatdt</strong> – Optional interval (in seconds) on which to repeat the release of the ParticleSet</p></li>
<li><p><strong>lonlatdepth_dtype</strong> – Floating precision for lon, lat, depth particle coordinates.
It is either np.float32 or np.float64. Default is np.float32 if fieldset.U.interp_method is ‘linear’
and np.float64 if the interpolation method is ‘cgrid_velocity’</p></li>
<li><p><strong>pid_orig</strong> – Optional list of (offsets for) the particle IDs</p></li>
<li><p><strong>partitions</strong> – List of cores on which to distribute the particles for MPI runs. Default: None, in which case particles
are distributed automatically on the processors</p></li>
</ul>
</dd>
</dl>
<p>Other Variables can be initialised using further arguments (e.g. v=… for a Variable named ‘v’)</p>
<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.Kernel">
<code class="sig-name descname">Kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pyfunc</span></em>, <em class="sig-param"><span class="n">c_include</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">delete_cfiles</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.Kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method to convert a <cite>pyfunc</cite> into a <a class="reference internal" href="#parcels.kernel.Kernel" title="parcels.kernel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.kernel.Kernel</span></code></a> object
based on <cite>fieldset</cite> and <cite>ptype</cite> of the ParticleSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>delete_cfiles</strong> – Boolean whether to delete the C-files after compilation in JIT mode (default is True)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.ParticleFile">
<code class="sig-name descname">ParticleFile</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.ParticleFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.ParticleFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method to initialise a <a class="reference internal" href="#parcels.particlefile.ParticleFile" title="parcels.particlefile.ParticleFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlefile.ParticleFile</span></code></a>
object from the ParticleSet</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particles</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add particles to the ParticleSet. Note that this is an
incremental add, the particles will be added to the ParticleSet
on which this function is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>particles</strong> – Another ParticleSet containing particles to add
to this one.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The current ParticleSet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.cstruct">
<code class="sig-name descname">cstruct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.cstruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.cstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>‘cstruct’ returns the ctypes mapping of the combined collections cstruct and the fieldset cstruct.
This depends on the specific structure in question.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.data_indices">
<code class="sig-name descname">data_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variable_name</span></em>, <em class="sig-param"><span class="n">compare_values</span></em>, <em class="sig-param"><span class="n">invert</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.data_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.data_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the indices of all particles where the value of
<cite>variable_name</cite> equals (one of) <cite>compare_values</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_name</strong> – Name of the variable to check.</p></li>
<li><p><strong>compare_values</strong> – Value or list of values to compare to.</p></li>
<li><p><strong>invert</strong> – Whether to invert the selection. I.e., when True,
return all indices that do not equal (one of)
<cite>compare_values</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Numpy array of indices that satisfy the test.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.density">
<code class="sig-name descname">density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">field_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">particle_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">relative</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">area_scale</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to calculate the density of particles in a ParticleSet from their locations,
through a 2D histogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> – Optional <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object to calculate the histogram
on. Default is <cite>fieldset.U</cite></p></li>
<li><p><strong>particle_val</strong> – Optional numpy-array of values to weigh each particle with,
or string name of particle variable to use weigh particles with.
Default is None, resulting in a value of 1 for each particle</p></li>
<li><p><strong>relative</strong> – Boolean to control whether the density is scaled by the total
weight of all particles. Default is False</p></li>
<li><p><strong>area_scale</strong> – Boolean to control whether the density is scaled by the area
(in m^2) of each grid cell. Default is False</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.error_particles">
<em class="property">property </em><code class="sig-name descname">error_particles</code><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.error_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an iterator over all particles that are in an error state.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Collection iterator over error particles.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.from_field">
<em class="property">classmethod </em><code class="sig-name descname">from_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">pclass</span></em>, <em class="sig-param"><span class="n">start_field</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'monte_carlo'</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repeatdt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.from_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.from_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the ParticleSet randomly drawn according to distribution from a field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object from which to sample velocity</p></li>
<li><p><strong>pclass</strong> – mod:<cite>parcels.particle.JITParticle</cite> or <a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a>
object that defines custom particle</p></li>
<li><p><strong>start_field</strong> – Field for initialising particles stochastically (horizontally)  according to the presented density field.</p></li>
<li><p><strong>size</strong> – Initial size of particle set</p></li>
<li><p><strong>mode</strong> – Type of random sampling. Currently only ‘monte_carlo’ is implemented</p></li>
<li><p><strong>depth</strong> – Optional list of initial depth values for particles. Default is 0m</p></li>
<li><p><strong>time</strong> – Optional start time value for particles. Default is fieldset.U.time[0]</p></li>
<li><p><strong>repeatdt</strong> – Optional interval (in seconds) on which to repeat the release of the ParticleSet</p></li>
<li><p><strong>lonlatdepth_dtype</strong> – Floating precision for lon, lat, depth particle coordinates.
It is either np.float32 or np.float64. Default is np.float32 if fieldset.U.interp_method is ‘linear’
and np.float64 if the interpolation method is ‘cgrid_velocity’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.from_particlefile">
<em class="property">classmethod </em><code class="sig-name descname">from_particlefile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">pclass</span></em>, <em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">restart</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">restarttime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repeatdt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.from_particlefile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.from_particlefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the ParticleSet from a netcdf ParticleFile.
This creates a new ParticleSet based on locations of all particles written
in a netcdf ParticleFile at a certain time. Particle IDs are preserved if restart=True</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object from which to sample velocity</p></li>
<li><p><strong>pclass</strong> – mod:<cite>parcels.particle.JITParticle</cite> or <a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a>
object that defines custom particle</p></li>
<li><p><strong>filename</strong> – Name of the particlefile from which to read initial conditions</p></li>
<li><p><strong>restart</strong> – Boolean to signal if pset is used for a restart (default is True).
In that case, Particle IDs are preserved.</p></li>
<li><p><strong>restarttime</strong> – time at which the Particles will be restarted. Default is the last time written.
Alternatively, restarttime could be a time value (including np.datetime64) or
a callable function such as np.nanmin. The last is useful when running with dt &lt; 0.</p></li>
<li><p><strong>repeatdt</strong> – Optional interval (in seconds) on which to repeat the release of the ParticleSet</p></li>
<li><p><strong>lonlatdepth_dtype</strong> – Floating precision for lon, lat, depth particle coordinates.
It is either np.float32 or np.float64. Default is np.float32 if fieldset.U.interp_method is ‘linear’
and np.float64 if the interpolation method is ‘cgrid_velocity’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.monte_carlo_sample">
<em class="property">classmethod </em><code class="sig-name descname">monte_carlo_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_field</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'monte_carlo'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.monte_carlo_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.monte_carlo_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a starting field into a monte-carlo sample of lons and lats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>start_field</strong> – <code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.Field</span></code> object for initialising particles stochastically (horizontally)  according to the presented density field.</p>
</dd>
</dl>
<p>returns list(lon), list(lat)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.num_error_particles">
<em class="property">property </em><code class="sig-name descname">num_error_particles</code><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.num_error_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of particles that are in an error state.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of error particles.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.populate_indices">
<code class="sig-name descname">populate_indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.populate_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.populate_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-populate guesses of particle xi/yi indices using a kdtree.</p>
<p>This is only intended for curvilinear grids, where the initial index search
may be quite expensive.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.remove_booleanvector">
<code class="sig-name descname">remove_booleanvector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.remove_booleanvector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.remove_booleanvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to remove particles from the ParticleSet, based on an array of booleans</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.remove_indices">
<code class="sig-name descname">remove_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.remove_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.remove_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to remove particles from the ParticleSet, based on their <cite>indices</cite></p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.set_variable_write_status">
<code class="sig-name descname">set_variable_write_status</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">write_status</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.set_variable_write_status"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.set_variable_write_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to set the write status of a Variable
:param var: Name of the variable (string)
:param write_status: Write status of the variable (True, False or</p>
<blockquote>
<div><p>‘once’)</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">with_particles</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">field</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">land</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">savefile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">animation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to ‘show’ a Parcels ParticleSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>with_particles</strong> – Boolean whether to show particles</p></li>
<li><p><strong>show_time</strong> – Time at which to show the ParticleSet</p></li>
<li><p><strong>field</strong> – Field to plot under particles (either None, a Field object, or ‘vector’)</p></li>
<li><p><strong>domain</strong> – dictionary (with keys ‘N’, ‘S’, ‘E’, ‘W’) defining domain to show</p></li>
<li><p><strong>projection</strong> – type of cartopy projection to use (default PlateCarree)</p></li>
<li><p><strong>land</strong> – Boolean whether to show land. This is ignored for flat meshes</p></li>
<li><p><strong>vmin</strong> – minimum colour scale (only in single-plot mode)</p></li>
<li><p><strong>vmax</strong> – maximum colour scale (only in single-plot mode)</p></li>
<li><p><strong>savefile</strong> – Name of a file to save the plot to</p></li>
<li><p><strong>animation</strong> – Boolean whether result is a single plot, or an animation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.particlesetsoa.ParticleSetSOA.to_dict">
<code class="sig-name descname">to_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pfile</span></em>, <em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">deleted_only</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/particlesetsoa.html#ParticleSetSOA.to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.particlesetsoa.ParticleSetSOA.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all Particle data from one time step to a python dictionary.
:param pfile: ParticleFile object requesting the conversion
:param time: Time at which to write ParticleSet
:param deleted_only: Flag to write only the deleted Particles
returns two dictionaries: one for all variables to be written each outputdt,</p>
<blockquote>
<div><p>and one for all variables to be written once</p>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.fieldset">
<span id="parcels-fieldset-module"></span><h2>parcels.fieldset module<a class="headerlink" href="#module-parcels.fieldset" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.fieldset.FieldSet">
<em class="property">class </em><code class="sig-prename descclassname">parcels.fieldset.</code><code class="sig-name descname">FieldSet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">U</span></em>, <em class="sig-param"><span class="n">V</span></em>, <em class="sig-param"><span class="n">fields</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>FieldSet class that holds hydrodynamic data needed to execute particles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> – <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object for zonal velocity component</p></li>
<li><p><strong>V</strong> – <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object for meridional velocity component</p></li>
<li><p><strong>fields</strong> – Dictionary of additional <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> objects</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="parcels.fieldset.FieldSet.add_constant">
<code class="sig-name descname">add_constant</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.add_constant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.add_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a constant to the FieldSet. Note that all constants are
stored as 32-bit floats. While constants can be updated during
execution in SciPy mode, they can not be updated in JIT mode.</p>
<p>Tutorials using fieldset.add_constant:
<a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_analyticaladvection.ipynb">Analytical advection</a>
<a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_diffusion.ipynb">Diffusion</a>
<a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_periodic_boundaries.ipynb">Periodic boundaries</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the constant</p></li>
<li><p><strong>value</strong> – Value of the constant (stored as 32-bit float)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.add_constant_field">
<code class="sig-name descname">add_constant_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'flat'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.add_constant_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.add_constant_field" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Wrapper function to add a Field that is constant in space,</dt><dd><p>useful e.g. when using constant horizontal diffusivity</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object to be added</p></li>
<li><p><strong>value</strong> – Value of the constant field (stored as 32-bit float)</p></li>
<li><p><strong>units</strong> – Optional UnitConverter object, to convert units
(e.g. for Horizontal diffusivity from m2/s to degree2/s)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.add_field">
<code class="sig-name descname">add_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">field</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.add_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.add_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object to the FieldSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> – <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object to be added</p></li>
<li><p><strong>name</strong> – Name of the <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object to be added</p></li>
</ul>
</dd>
</dl>
<p>For usage examples see the following tutorials:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_NestedFields.ipynb">Nested Fields</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">Unit converters</a></p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.add_periodic_halo">
<code class="sig-name descname">add_periodic_halo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zonal</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">meridional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">halosize</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.add_periodic_halo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.add_periodic_halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a ‘halo’ to all <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> objects in a FieldSet,
through extending the Field (and lon/lat) by copying a small portion
of the field on one side of the domain to the other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zonal</strong> – Create a halo in zonal direction (boolean)</p></li>
<li><p><strong>meridional</strong> – Create a halo in meridional direction (boolean)</p></li>
<li><p><strong>halosize</strong> – size of the halo (in grid points). Default is 5 grid points</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.add_vector_field">
<code class="sig-name descname">add_vector_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vfield</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.add_vector_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.add_vector_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a <a class="reference internal" href="#parcels.field.VectorField" title="parcels.field.VectorField"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.VectorField</span></code></a> object to the FieldSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vfield</strong> – <a class="reference internal" href="#parcels.field.VectorField" title="parcels.field.VectorField"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.VectorField</span></code></a> object to be added</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.advancetime">
<code class="sig-name descname">advancetime</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset_new</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.advancetime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.advancetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace oldest time on FieldSet with new FieldSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fieldset_new</strong> – FieldSet snapshot with which the oldest time has to be replaced</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.computeTimeChunk">
<code class="sig-name descname">computeTimeChunk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.computeTimeChunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.computeTimeChunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a chunk of three data time steps into the FieldSet.
This is used when FieldSet uses data imported from netcdf,
with default option deferred_load. The loaded time steps are at or immediatly before time
and the two time steps immediately following time if dt is positive (and inversely for negative dt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> – Time around which the FieldSet chunks are to be loaded. Time is provided as a double, relatively to Fieldset.time_origin</p></li>
<li><p><strong>dt</strong> – time step of the integration scheme</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_b_grid_dataset">
<em class="property">classmethod </em><code class="sig-name descname">from_b_grid_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tracer_interp_method</span><span class="o">=</span><span class="default_value">'bgrid_tracer'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_b_grid_dataset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_b_grid_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet object from NetCDF files of Bgrid fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filenames</strong> – Dictionary mapping variables to file(s). The
filepath may contain wildcards to indicate multiple files,
or be a list of file.
filenames can be a list [files], a dictionary {var:[files]},
a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),
or a dictionary of dictionaries {var:{dim:[files]}}
time values are in filenames[data]</p></li>
<li><p><strong>variables</strong> – Dictionary mapping variables to variable
names in the netCDF file(s).</p></li>
<li><p><strong>dimensions</strong> – <p>Dictionary mapping data dimensions (lon,
lat, depth, time, data) to dimensions in the netCF file(s).
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable.
U and V velocity nodes are not located as W velocity and T tracer nodes (see <a class="reference external" href="http://www.cesm.ucar.edu/models/cesm1.0/pop2/doc/sci/POPRefManual.pdf">http://www.cesm.ucar.edu/models/cesm1.0/pop2/doc/sci/POPRefManual.pdf</a> ).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>U[k,j+1,i],V[k,j+1,i]</p></td>
<td></td>
<td><p>U[k,j+1,i+1],V[k,j+1,i+1]</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>W[k:k+2,j+1,i+1],T[k,j+1,i+1]</p></td>
<td></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>U[k,j,i],V[k,j,i]</p></td>
<td rowspan="2"></td>
<td rowspan="2"><p>U[k,j,i+1],V[k,j,i+1]</p></td>
</tr>
<tr class="row-even"></tr>
</tbody>
</table>
<dl class="simple">
<dt>In 2D: U and V nodes are on the cell vertices and interpolated bilinearly as a A-grid.</dt><dd><p>T node is at the cell centre and interpolated constant per cell as a C-grid.</p>
</dd>
<dt>In 3D: U and V nodes are at the midlle of the cell vertical edges,</dt><dd><p>They are interpolated bilinearly (independently of z) in the cell.
W nodes are at the centre of the horizontal interfaces.
They are interpolated linearly (as a function of z) in the cell.
T node is at the cell centre, and constant per cell.</p>
</dd>
</dl>
</p></li>
<li><p><strong>indices</strong> – Optional dictionary of indices for each dimension
to read from file(s), to allow for reading of subset of data.
Default is to read the full extent of each dimension.
Note that negative indices are not allowed.</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>tracer_interp_method</strong> – Method for interpolation of tracer fields. It is recommended to use ‘bgrid_tracer’ (default)
Note that in the case of from_pop() and from_bgrid(), the velocity fields are default to ‘bgrid_velocity’</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_c_grid_dataset">
<em class="property">classmethod </em><code class="sig-name descname">from_c_grid_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tracer_interp_method</span><span class="o">=</span><span class="default_value">'cgrid_tracer'</span></em>, <em class="sig-param"><span class="n">gridindexingtype</span><span class="o">=</span><span class="default_value">'nemo'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_c_grid_dataset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_c_grid_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet object from NetCDF files of Curvilinear NEMO fields.</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/documentation_indexing.ipynb">here</a>
for a more detailed explanation of the different methods that can be used for c-grid datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filenames</strong> – Dictionary mapping variables to file(s). The
filepath may contain wildcards to indicate multiple files,
or be a list of file.
filenames can be a list [files], a dictionary {var:[files]},
a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),
or a dictionary of dictionaries {var:{dim:[files]}}
time values are in filenames[data]</p></li>
<li><p><strong>variables</strong> – Dictionary mapping variables to variable
names in the netCDF file(s).</p></li>
<li><p><strong>dimensions</strong> – <p>Dictionary mapping data dimensions (lon,
lat, depth, time, data) to dimensions in the netCF file(s).
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable.
Watch out: NEMO is discretised on a C-grid:
U and V velocities are not located on the same nodes (see <a class="reference external" href="https://www.nemo-ocean.eu/doc/node19.html">https://www.nemo-ocean.eu/doc/node19.html</a> ).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>V[k,j+1,i+1]</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>U[k,j+1,i]</p></td>
<td><p>W[k:k+2,j+1,i+1],T[k,j+1,i+1]</p></td>
<td><p>U[k,j+1,i+1]</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"></td>
<td rowspan="2"><p>V[k,j,i+1]</p></td>
<td rowspan="2"></td>
</tr>
<tr class="row-even"></tr>
</tbody>
</table>
<p>To interpolate U, V velocities on the C-grid, Parcels needs to read the f-nodes,
which are located on the corners of the cells.
(for indexing details: <a class="reference external" href="https://www.nemo-ocean.eu/doc/img360.png">https://www.nemo-ocean.eu/doc/img360.png</a> )
In 3D, the depth is the one corresponding to W nodes.</p>
</p></li>
<li><p><strong>indices</strong> – Optional dictionary of indices for each dimension
to read from file(s), to allow for reading of subset of data.
Default is to read the full extent of each dimension.
Note that negative indices are not allowed.</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>tracer_interp_method</strong> – Method for interpolation of tracer fields. It is recommended to use ‘cgrid_tracer’ (default)
Note that in the case of from_nemo() and from_cgrid(), the velocity fields are default to ‘cgrid_velocity’</p></li>
<li><p><strong>gridindexingtype</strong> – The type of gridindexing. Set to ‘nemo’ in FieldSet.from_nemo()
See also the Grid indexing documentation on oceanparcels.org</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_data">
<em class="property">classmethod </em><code class="sig-name descname">from_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">transpose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise FieldSet object from raw data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – <p>Dictionary mapping field names to numpy arrays.
Note that at least a ‘U’ and ‘V’ numpy array need to be given, and that
the built-in Advection kernels assume that U and V are in m/s</p>
<ol class="arabic simple">
<li><p>If data shape is [xdim, ydim], [xdim, ydim, zdim], [xdim, ydim, tdim] or [xdim, ydim, zdim, tdim],
whichever is relevant for the dataset, use the flag transpose=True</p></li>
<li><p>If data shape is [ydim, xdim], [zdim, ydim, xdim], [tdim, ydim, xdim] or [tdim, zdim, ydim, xdim],
use the flag transpose=False (default value)</p></li>
<li><p>If data has any other shape, you first need to reorder it</p></li>
</ol>
</p></li>
<li><p><strong>dimensions</strong> – Dictionary mapping field dimensions (lon,
lat, depth, time) to numpy arrays.
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable
(e.g. dimensions[‘U’], dimensions[‘V’], etc).</p></li>
<li><p><strong>transpose</strong> – Boolean whether to transpose data on read-in</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation, see also <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">this tutorial</a>:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
</ul>
</dd>
</dl>
<ul class="simple">
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_analyticaladvection.ipynb">Analytical advection</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_diffusion.ipynb">Diffusion</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_interpolation.ipynb">Interpolation</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">Unit converters</a></p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_mitgcm">
<em class="property">classmethod </em><code class="sig-name descname">from_mitgcm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tracer_interp_method</span><span class="o">=</span><span class="default_value">'cgrid_tracer'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_mitgcm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_mitgcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet object from NetCDF files of MITgcm fields.
All parameters and keywords are exactly the same as for FieldSet.from_nemo(), except that
gridindexing is set to ‘mitgcm’ for grids that have the shape</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>V[k,j+1,i]</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>U[k,j,i]</p></td>
<td><p>W[k-1:k,j,i], T[k,j,i]</p></td>
<td><p>U[k,j,i+1]</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"></td>
<td rowspan="2"><p>V[k,j,i]</p></td>
<td rowspan="2"></td>
</tr>
<tr class="row-even"></tr>
</tbody>
</table>
<p>For indexing details: <a class="reference external" href="https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#spatial-discretization-of-the-dynamical-equations">https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#spatial-discretization-of-the-dynamical-equations</a>
Note that vertical velocity (W) is assumed postive in the positive z direction (which is upward in MITgcm)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_mom5">
<em class="property">classmethod </em><code class="sig-name descname">from_mom5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tracer_interp_method</span><span class="o">=</span><span class="default_value">'bgrid_tracer'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_mom5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_mom5" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet object from NetCDF files of MOM5 fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filenames</strong> – Dictionary mapping variables to file(s). The
filepath may contain wildcards to indicate multiple files,
or be a list of file.
filenames can be a list [files], a dictionary {var:[files]},
a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),
or a dictionary of dictionaries {var:{dim:[files]}}
time values are in filenames[data]</p></li>
<li><p><strong>variables</strong> – Dictionary mapping variables to variable names in the netCDF file(s).
Note that the built-in Advection kernels assume that U and V are in m/s</p></li>
<li><p><strong>dimensions</strong> – <p>Dictionary mapping data dimensions (lon,
lat, depth, time, data) to dimensions in the netCF file(s).
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>U[k,j+1,i],V[k,j+1,i]</p></td>
<td></td>
<td><p>U[k,j+1,i+1],V[k,j+1,i+1]</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>W[k-1:k+1,j+1,i+1],T[k,j+1,i+1]</p></td>
<td></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>U[k,j,i],V[k,j,i]</p></td>
<td rowspan="2"></td>
<td rowspan="2"><p>U[k,j,i+1],V[k,j,i+1]</p></td>
</tr>
<tr class="row-even"></tr>
</tbody>
</table>
<dl class="simple">
<dt>In 2D: U and V nodes are on the cell vertices and interpolated bilinearly as a A-grid.</dt><dd><p>T node is at the cell centre and interpolated constant per cell as a C-grid.</p>
</dd>
<dt>In 3D: U and V nodes are at the midlle of the cell vertical edges,</dt><dd><p>They are interpolated bilinearly (independently of z) in the cell.
W nodes are at the centre of the horizontal interfaces, but below the U and V.
They are interpolated linearly (as a function of z) in the cell.
Note that W is normally directed upward in MOM5, but Parcels requires W
in the positive z-direction (downward) so W is multiplied by -1.
T node is at the cell centre, and constant per cell.</p>
</dd>
</dl>
</p></li>
<li><p><strong>indices</strong> – Optional dictionary of indices for each dimension
to read from file(s), to allow for reading of subset of data.
Default is to read the full extent of each dimension.
Note that negative indices are not allowed.</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation, see also <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb</a>:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>tracer_interp_method</strong> – Method for interpolation of tracer fields. It is recommended to use ‘bgrid_tracer’ (default)
Note that in the case of from_mom5() and from_bgrid(), the velocity fields are default to ‘bgrid_velocity’</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_nemo">
<em class="property">classmethod </em><code class="sig-name descname">from_nemo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tracer_interp_method</span><span class="o">=</span><span class="default_value">'cgrid_tracer'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_nemo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_nemo" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet object from NetCDF files of Curvilinear NEMO fields.</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_nemo_curvilinear.ipynb">here</a>
for a detailed tutorial on the setup for 2D NEMO fields and <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_nemo_3D.ipynb">here</a>
for the tutorial on the setup for 3D NEMO fields.</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/documentation_indexing.ipynb">here</a>
for a more detailed explanation of the different methods that can be used for c-grid datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filenames</strong> – Dictionary mapping variables to file(s). The
filepath may contain wildcards to indicate multiple files,
or be a list of file.
filenames can be a list [files], a dictionary {var:[files]},
a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),
or a dictionary of dictionaries {var:{dim:[files]}}
time values are in filenames[data]</p></li>
<li><p><strong>variables</strong> – Dictionary mapping variables to variable names in the netCDF file(s).
Note that the built-in Advection kernels assume that U and V are in m/s</p></li>
<li><p><strong>dimensions</strong> – <p>Dictionary mapping data dimensions (lon,
lat, depth, time, data) to dimensions in the netCF file(s).
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable.
Watch out: NEMO is discretised on a C-grid:
U and V velocities are not located on the same nodes (see <a class="reference external" href="https://www.nemo-ocean.eu/doc/node19.html">https://www.nemo-ocean.eu/doc/node19.html</a> ).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>V[k,j+1,i+1]</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>U[k,j+1,i]</p></td>
<td><p>W[k:k+2,j+1,i+1],T[k,j+1,i+1]</p></td>
<td><p>U[k,j+1,i+1]</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"></td>
<td rowspan="2"><p>V[k,j,i+1]</p></td>
<td rowspan="2"></td>
</tr>
<tr class="row-even"></tr>
</tbody>
</table>
<p>To interpolate U, V velocities on the C-grid, Parcels needs to read the f-nodes,
which are located on the corners of the cells.
(for indexing details: <a class="reference external" href="https://www.nemo-ocean.eu/doc/img360.png">https://www.nemo-ocean.eu/doc/img360.png</a> )
In 3D, the depth is the one corresponding to W nodes
The gridindexingtype is set to ‘nemo’. See also the Grid indexing documentation on oceanparcels.org</p>
</p></li>
<li><p><strong>indices</strong> – Optional dictionary of indices for each dimension
to read from file(s), to allow for reading of subset of data.
Default is to read the full extent of each dimension.
Note that negative indices are not allowed.</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation, see also <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">this tutorial</a>:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>tracer_interp_method</strong> – Method for interpolation of tracer fields. It is recommended to use ‘cgrid_tracer’ (default)
Note that in the case of from_nemo() and from_cgrid(), the velocity fields are default to ‘cgrid_velocity’</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading. Default is None (no chunking)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_netcdf">
<em class="property">classmethod </em><code class="sig-name descname">from_netcdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fieldtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">timestamps</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">deferred_load</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_netcdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_netcdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet object from NetCDF files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filenames</strong> – Dictionary mapping variables to file(s). The
filepath may contain wildcards to indicate multiple files
or be a list of file.
filenames can be a list [files], a dictionary {var:[files]},
a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),
or a dictionary of dictionaries {var:{dim:[files]}}.
time values are in filenames[data]</p></li>
<li><p><strong>variables</strong> – Dictionary mapping variables to variable names in the netCDF file(s).
Note that the built-in Advection kernels assume that U and V are in m/s</p></li>
<li><p><strong>dimensions</strong> – Dictionary mapping data dimensions (lon,
lat, depth, time, data) to dimensions in the netCF file(s).
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable
(e.g. dimensions[‘U’], dimensions[‘V’], etc).</p></li>
<li><p><strong>indices</strong> – Optional dictionary of indices for each dimension
to read from file(s), to allow for reading of subset of data.
Default is to read the full extent of each dimension.
Note that negative indices are not allowed.</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation, see also <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">this tuturial</a>:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>timestamps</strong> – list of lists or array of arrays containing the timestamps for
each of the files in filenames. Outer list/array corresponds to files, inner
array corresponds to indices within files.
Default is None if dimensions includes time.</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>deferred_load</strong> – boolean whether to only pre-load data (in deferred mode) or
fully load them (default: True). It is advised to deferred load the data, since in
that case Parcels deals with a better memory management during particle set execution.
deferred_load=False is however sometimes necessary for plotting the fields.</p></li>
<li><p><strong>interp_method</strong> – Method for interpolation. Options are ‘linear’ (default), ‘nearest’,
‘linear_invdist_land_tracer’, ‘cgrid_velocity’, ‘cgrid_tracer’ and ‘bgrid_velocity’</p></li>
<li><p><strong>gridindexingtype</strong> – The type of gridindexing. Either ‘nemo’ (default) or ‘mitgcm’ are supported.
See also the Grid indexing documentation on oceanparcels.org</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading. Default is None (no chunking). Can be None or False (no chunking),
‘auto’ (chunking is done in the background, but results in one grid per field individually), or a dict in the format
‘{parcels_varname: {netcdf_dimname : (parcels_dimname, chunksize_as_int)}, …}’, where ‘parcels_dimname’ is one of (‘time’, ‘depth’, ‘lat’, ‘lon’)</p></li>
<li><p><strong>netcdf_engine</strong> – engine to use for netcdf reading in xarray. Default is ‘netcdf’,
but in cases where this doesn’t work, setting netcdf_engine=’scipy’ could help</p></li>
</ul>
</dd>
</dl>
<p>For usage examples see the following tutorials:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/parcels_tutorial.ipynb">Basic Parcels setup</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_Argofloats.ipynb">Argo floats</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_timestamps.ipynb">Timestamps</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_timevaryingdepthdimensions.ipynb">Time-evolving depth dimensions</a></p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_parcels">
<em class="property">classmethod </em><code class="sig-name descname">from_parcels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basename</span></em>, <em class="sig-param"><span class="n">uvar</span><span class="o">=</span><span class="default_value">'vozocrtx'</span></em>, <em class="sig-param"><span class="n">vvar</span><span class="o">=</span><span class="default_value">'vomecrty'</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">extra_fields</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">deferred_load</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_parcels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_parcels" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet data from NetCDF files using the Parcels FieldSet.write() conventions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>basename</strong> – Base name of the file(s); may contain
wildcards to indicate multiple files.</p></li>
<li><p><strong>indices</strong> – Optional dictionary of indices for each dimension
to read from file(s), to allow for reading of subset of data.
Default is to read the full extent of each dimension.
Note that negative indices are not allowed.</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>extra_fields</strong> – Extra fields to read beyond U and V</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>deferred_load</strong> – boolean whether to only pre-load data (in deferred mode) or
fully load them (default: True). It is advised to deferred load the data, since in
that case Parcels deals with a better memory management during particle set execution.
deferred_load=False is however sometimes necessary for plotting the fields.</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_pop">
<em class="property">classmethod </em><code class="sig-name descname">from_pop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tracer_interp_method</span><span class="o">=</span><span class="default_value">'bgrid_tracer'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">depth_units</span><span class="o">=</span><span class="default_value">'m'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_pop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Initialises FieldSet object from NetCDF files of POP fields.</dt><dd><p>It is assumed that the velocities in the POP fields is in cm/s.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filenames</strong> – Dictionary mapping variables to file(s). The
filepath may contain wildcards to indicate multiple files,
or be a list of file.
filenames can be a list [files], a dictionary {var:[files]},
a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data),
or a dictionary of dictionaries {var:{dim:[files]}}
time values are in filenames[data]</p></li>
<li><p><strong>variables</strong> – Dictionary mapping variables to variable names in the netCDF file(s).
Note that the built-in Advection kernels assume that U and V are in m/s</p></li>
<li><p><strong>dimensions</strong> – <p>Dictionary mapping data dimensions (lon,
lat, depth, time, data) to dimensions in the netCF file(s).
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable.
Watch out: POP is discretised on a B-grid:
U and V velocity nodes are not located as W velocity and T tracer nodes (see <a class="reference external" href="http://www.cesm.ucar.edu/models/cesm1.0/pop2/doc/sci/POPRefManual.pdf">http://www.cesm.ucar.edu/models/cesm1.0/pop2/doc/sci/POPRefManual.pdf</a> ).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>U[k,j+1,i],V[k,j+1,i]</p></td>
<td></td>
<td><p>U[k,j+1,i+1],V[k,j+1,i+1]</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>W[k:k+2,j+1,i+1],T[k,j+1,i+1]</p></td>
<td></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>U[k,j,i],V[k,j,i]</p></td>
<td rowspan="2"></td>
<td rowspan="2"><p>U[k,j,i+1],V[k,j,i+1]</p></td>
</tr>
<tr class="row-even"></tr>
</tbody>
</table>
<dl class="simple">
<dt>In 2D: U and V nodes are on the cell vertices and interpolated bilinearly as a A-grid.</dt><dd><p>T node is at the cell centre and interpolated constant per cell as a C-grid.</p>
</dd>
<dt>In 3D: U and V nodes are at the middle of the cell vertical edges,</dt><dd><p>They are interpolated bilinearly (independently of z) in the cell.
W nodes are at the centre of the horizontal interfaces.
They are interpolated linearly (as a function of z) in the cell.
T node is at the cell centre, and constant per cell.
Note that Parcels assumes that the length of the depth dimension (at the W-points)
is one larger than the size of the velocity and tracer fields in the depth dimension.</p>
</dd>
</dl>
</p></li>
<li><p><strong>indices</strong> – Optional dictionary of indices for each dimension
to read from file(s), to allow for reading of subset of data.
Default is to read the full extent of each dimension.
Note that negative indices are not allowed.</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation, see also <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">this tutorial</a>:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>tracer_interp_method</strong> – Method for interpolation of tracer fields. It is recommended to use ‘bgrid_tracer’ (default)
Note that in the case of from_pop() and from_bgrid(), the velocity fields are default to ‘bgrid_velocity’</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading</p></li>
<li><p><strong>depth_units</strong> – The units of the vertical dimension. Default in Parcels is ‘m’,
but many POP outputs are in ‘cm’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.from_xarray_dataset">
<em class="property">classmethod </em><code class="sig-name descname">from_xarray_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ds</span></em>, <em class="sig-param"><span class="n">variables</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.from_xarray_dataset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.from_xarray_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialises FieldSet data from xarray Datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ds</strong> – xarray Dataset.
Note that the built-in Advection kernels assume that U and V are in m/s</p></li>
<li><p><strong>variables</strong> – Dictionary mapping parcels variable names to data variables in the xarray Dataset.</p></li>
<li><p><strong>dimensions</strong> – Dictionary mapping data dimensions (lon,
lat, depth, time, data) to dimensions in the xarray Dataset.
Note that dimensions can also be a dictionary of dictionaries if
dimension names are different for each variable
(e.g. dimensions[‘U’], dimensions[‘V’], etc).</p></li>
<li><p><strong>fieldtype</strong> – Optional dictionary mapping fields to fieldtypes to be used for UnitConverter.
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation, see also <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">this tutorial</a>:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object). (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.get_fields">
<code class="sig-name descname">get_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.get_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.get_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all the <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> and <a class="reference internal" href="#parcels.field.VectorField" title="parcels.field.VectorField"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.field.VectorField</span></code></a>
objects associated with this FieldSet</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.fieldset.FieldSet.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/fieldset.html#FieldSet.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.fieldset.FieldSet.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write FieldSet to NetCDF file using NEMO convention</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – Basename of the output fileset</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.field">
<span id="parcels-field-module"></span><h2>parcels.field module<a class="headerlink" href="#module-parcels.field" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.field.Field">
<em class="property">class </em><code class="sig-prename descclassname">parcels.field.</code><code class="sig-name descname">Field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">lon</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'flat'</span></em>, <em class="sig-param"><span class="n">timestamps</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fieldtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">transpose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">interp_method</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">gridindexingtype</span><span class="o">=</span><span class="default_value">'nemo'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class that encapsulates access to field data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the field</p></li>
<li><p><strong>data</strong> – <p>2D, 3D or 4D numpy array of field data.</p>
<ol class="arabic simple">
<li><p>If data shape is [xdim, ydim], [xdim, ydim, zdim], [xdim, ydim, tdim] or [xdim, ydim, zdim, tdim],
whichever is relevant for the dataset, use the flag transpose=True</p></li>
<li><p>If data shape is [ydim, xdim], [zdim, ydim, xdim], [tdim, ydim, xdim] or [tdim, zdim, ydim, xdim],
use the flag transpose=False</p></li>
<li><p>If data has any other shape, you first need to reorder it</p></li>
</ol>
</p></li>
<li><p><strong>lon</strong> – Longitude coordinates (numpy vector or array) of the field (only if grid is None)</p></li>
<li><p><strong>lat</strong> – Latitude coordinates (numpy vector or array) of the field (only if grid is None)</p></li>
<li><p><strong>depth</strong> – Depth coordinates (numpy vector or array) of the field (only if grid is None)</p></li>
<li><p><strong>time</strong> – Time coordinates (numpy vector) of the field (only if grid is None)</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation: (only if grid is None)</p>
<ol class="arabic simple">
<li><p>spherical: Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat (default): No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>timestamps</strong> – A numpy array containing the timestamps for each of the files in filenames, for loading
from netCDF files only. Default is None if the netCDF dimensions dictionary includes time.</p></li>
<li><p><strong>grid</strong> – <a class="reference internal" href="#parcels.grid.Grid" title="parcels.grid.Grid"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.grid.Grid</span></code></a> object containing all the lon, lat depth, time
mesh and time_origin information. Can be constructed from any of the Grid objects</p></li>
<li><p><strong>fieldtype</strong> – Type of Field to be used for UnitConverter when using SummedFields
(either ‘U’, ‘V’, ‘Kh_zonal’, ‘Kh_meridional’ or None)</p></li>
<li><p><strong>transpose</strong> – Transpose data to required (lon, lat) layout</p></li>
<li><p><strong>vmin</strong> – Minimum allowed value on the field. Data below this value are set to zero</p></li>
<li><p><strong>vmax</strong> – Maximum allowed value on the field. Data above this value are set to zero</p></li>
<li><p><strong>time_origin</strong> – Time origin (TimeConverter object) of the time axis (only if grid is None)</p></li>
<li><p><strong>interp_method</strong> – Method for interpolation. Options are ‘linear’ (default), ‘nearest’,
‘linear_invdist_land_tracer’, ‘cgrid_velocity’, ‘cgrid_tracer’ and ‘bgrid_velocity’</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation in time
(i.e. beyond the last available time snapshot)</p></li>
<li><p><strong>time_periodic</strong> – To loop periodically over the time component of the Field. It is set to either False or the length of the period (either float in seconds or datetime.timedelta object).
The last value of the time series can be provided (which is the same as the initial one) or not (Default: False)
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>(</strong><strong>opt.</strong><strong>)</strong> (<em>chunkdims_name_map</em>) – gives a name map to the FieldFileBuffer that declared a mapping between chunksize name, NetCDF dimension and Parcels dimension;
required only if currently incompatible OCM field is loaded and chunking is used by ‘chunksize’ (which is the default)</p></li>
</ul>
</dd>
</dl>
<p>For usage examples see the following tutorials:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_NestedFields.ipynb">Nested Fields</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_SummedFields.ipynb">Summed Fields</a></p></li>
</ul>
<dl class="py method">
<dt id="parcels.field.Field.add_periodic_halo">
<code class="sig-name descname">add_periodic_halo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zonal</span></em>, <em class="sig-param"><span class="n">meridional</span></em>, <em class="sig-param"><span class="n">halosize</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.add_periodic_halo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.add_periodic_halo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a ‘halo’ to all Fields in a FieldSet, through extending the Field (and lon/lat)
by copying a small portion of the field on one side of the domain to the other.
Before adding a periodic halo to the Field, it has to be added to the Grid on which the Field depends</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_periodic_boundaries.ipynb">this tutorial</a>
for a detailed explanation on how to set up periodic boundaries</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zonal</strong> – Create a halo in zonal direction (boolean)</p></li>
<li><p><strong>meridional</strong> – Create a halo in meridional direction (boolean)</p></li>
<li><p><strong>halosize</strong> – size of the halo (in grid points). Default is 5 grid points</p></li>
<li><p><strong>data</strong> – if data is not None, the periodic halo will be achieved on data instead of self.data and data will be returned</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.calc_cell_edge_sizes">
<code class="sig-name descname">calc_cell_edge_sizes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.calc_cell_edge_sizes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.calc_cell_edge_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to calculate cell sizes based on numpy.gradient method
Currently only works for Rectilinear Grids</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.cell_areas">
<code class="sig-name descname">cell_areas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.cell_areas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.cell_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to calculate cell sizes based on cell_edge_sizes
Currently only works for Rectilinear Grids</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.ctypes_struct">
<em class="property">property </em><code class="sig-name descname">ctypes_struct</code><a class="headerlink" href="#parcels.field.Field.ctypes_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ctypes struct object containing all relevant
pointers and sizes for this field.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">particle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">applyConversion</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate field values in space and time.</p>
<p>We interpolate linearly in time and apply implicit unit
conversion to the result. Note that we defer to
scipy.interpolate to perform spatial interpolation.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.from_netcdf">
<em class="property">classmethod </em><code class="sig-name descname">from_netcdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">variable</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">timestamps</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">deferred_load</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.from_netcdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.from_netcdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Create field from netCDF file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filenames</strong> – list of filenames to read for the field. filenames can be a list [files] or
a dictionary {dim:[files]} (if lon, lat, depth and/or data not stored in same files as data)
In the latetr case, time values are in filenames[data]</p></li>
<li><p><strong>variable</strong> – Tuple mapping field name to variable name in the NetCDF file.</p></li>
<li><p><strong>dimensions</strong> – Dictionary mapping variable names for the relevant dimensions in the NetCDF file</p></li>
<li><p><strong>indices</strong> – dictionary mapping indices for each dimension to read from file.
This can be used for reading in only a subregion of the NetCDF file.
Note that negative indices are not allowed.</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>timestamps</strong> – A numpy array of datetime64 objects containing the timestamps for each of the files in filenames.
Default is None if dimensions includes time.</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation in time
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – boolean whether to loop periodically over the time component of the FieldSet
This flag overrides the allow_time_interpolation and sets it to False</p></li>
<li><p><strong>deferred_load</strong> – boolean whether to only pre-load data (in deferred mode) or
fully load them (default: True). It is advised to deferred load the data, since in
that case Parcels deals with a better memory management during particle set execution.
deferred_load=False is however sometimes necessary for plotting the fields.</p></li>
<li><p><strong>gridindexingtype</strong> – The type of gridindexing. Either ‘nemo’ (default) or ‘mitgcm’ are supported.
See also the Grid indexing documentation on oceanparcels.org</p></li>
<li><p><strong>chunksize</strong> – size of the chunks in dask loading</p></li>
</ul>
</dd>
</dl>
<p>For usage examples see the following tutorial:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_timestamps.ipynb">Timestamps</a></p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.from_xarray">
<em class="property">classmethod </em><code class="sig-name descname">from_xarray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">da</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'spherical'</span></em>, <em class="sig-param"><span class="n">allow_time_extrapolation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_periodic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.from_xarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.from_xarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create field from xarray Variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>da</strong> – Xarray DataArray</p></li>
<li><p><strong>name</strong> – Name of the Field</p></li>
<li><p><strong>dimensions</strong> – Dictionary mapping variable names for the relevant dimensions in the DataArray</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
<li><p><strong>allow_time_extrapolation</strong> – boolean whether to allow for extrapolation in time
(i.e. beyond the last available time snapshot)
Default is False if dimensions includes time, else True</p></li>
<li><p><strong>time_periodic</strong> – boolean whether to loop periodically over the time component of the FieldSet
This flag overrides the allow_time_interpolation and sets it to False</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.set_depth_from_field">
<code class="sig-name descname">set_depth_from_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">field</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.set_depth_from_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.set_depth_from_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the depth dimensions from another (time-varying) field</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_timevaryingdepthdimensions.ipynb">this tutorial</a>
for a detailed explanation on how to set up time-evolving depth dimensions</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.set_scaling_factor">
<code class="sig-name descname">set_scaling_factor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">factor</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.set_scaling_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.set_scaling_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales the field data by some constant factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>factor</strong> – scaling factor</p>
</dd>
</dl>
<p>For usage examples see the following tutorial:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_unitconverters.ipynb">Unit converters</a></p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">animation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">show_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">depth_level</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">land</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">savefile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to ‘show’ a Parcels Field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>animation</strong> – Boolean whether result is a single plot, or an animation</p></li>
<li><p><strong>show_time</strong> – Time at which to show the Field (only in single-plot mode)</p></li>
<li><p><strong>domain</strong> – dictionary (with keys ‘N’, ‘S’, ‘E’, ‘W’) defining domain to show</p></li>
<li><p><strong>depth_level</strong> – depth level to be plotted (default 0)</p></li>
<li><p><strong>projection</strong> – type of cartopy projection to use (default PlateCarree)</p></li>
<li><p><strong>land</strong> – Boolean whether to show land. This is ignored for flat meshes</p></li>
<li><p><strong>vmin</strong> – minimum colour scale (only in single-plot mode)</p></li>
<li><p><strong>vmax</strong> – maximum colour scale (only in single-plot mode)</p></li>
<li><p><strong>savefile</strong> – Name of a file to save the plot to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.spatial_interpolation">
<code class="sig-name descname">spatial_interpolation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ti</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">particle</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.spatial_interpolation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.spatial_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate horizontal field values using a SciPy interpolator</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.temporal_interpolate_fullfield">
<code class="sig-name descname">temporal_interpolate_fullfield</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ti</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.temporal_interpolate_fullfield"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.temporal_interpolate_fullfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the data of a field between two snapshots,
using linear interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ti</strong> – Index in time array associated with time (via <a class="reference internal" href="#parcels.field.Field.time_index" title="parcels.field.Field.time_index"><code class="xref py py-func docutils literal notranslate"><span class="pre">time_index()</span></code></a>)</p></li>
<li><p><strong>time</strong> – Time to interpolate to</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Linearly interpolated field</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.time_index">
<code class="sig-name descname">time_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.time_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.time_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index in the time array associated with a given time</p>
<p>Note that we normalize to either the first or the last index
if the sampled value is outside the time value range.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.field.Field.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">varname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#Field.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.Field.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> to a netcdf file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – Basename of the file</p></li>
<li><p><strong>varname</strong> – Name of the field, to be appended to the filename</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="parcels.field.NestedField">
<em class="property">class </em><code class="sig-prename descclassname">parcels.field.</code><code class="sig-name descname">NestedField</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">F</span></em>, <em class="sig-param"><span class="n">V</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">W</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#NestedField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.NestedField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
<p>Class NestedField is a list of Fields from which the first one to be not declared out-of-boundaries
at particle position is interpolated. This induces that the order of the fields in the list matters.
Each one it its turn, a field is interpolated: if the interpolation succeeds or if an error other
than <cite>ErrorOutOfBounds</cite> is thrown, the function is stopped. Otherwise, next field is interpolated.
NestedField returns an <cite>ErrorOutOfBounds</cite> only if last field is as well out of boundaries.
NestedField is composed of either Fields or VectorFields.</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_NestedFields.ipynb">here</a>
for a detailed tutorial</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the NestedField</p></li>
<li><p><strong>F</strong> – List of fields (order matters). F can be a scalar Field, a VectorField, or the zonal component (U) of the VectorField</p></li>
<li><p><strong>V</strong> – List of fields defining the meridional component of a VectorField, if F is the zonal component. (default: None)</p></li>
<li><p><strong>W</strong> – List of fields defining the vertical component of a VectorField, if F and V are the zonal and meridional components (default: None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="parcels.field.SummedField">
<em class="property">class </em><code class="sig-prename descclassname">parcels.field.</code><code class="sig-name descname">SummedField</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">F</span></em>, <em class="sig-param"><span class="n">V</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">W</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#SummedField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.SummedField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
<p>Class SummedField is a list of Fields over which Field interpolation
is summed. This can e.g. be used when combining multiple flow fields,
where the total flow is the sum of all the individual flows.
Note that the individual Fields can be on different Grids.
Also note that, since SummedFields are lists, the individual Fields can
still be queried through their list index (e.g. SummedField[1]).
SummedField is composed of either Fields or VectorFields.</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_SummedFields.ipynb">here</a>
for a detailed tutorial</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the SummedField</p></li>
<li><p><strong>F</strong> – List of fields. F can be a scalar Field, a VectorField, or the zonal component (U) of the VectorField</p></li>
<li><p><strong>V</strong> – List of fields defining the meridional component of a VectorField, if F is the zonal component. (default: None)</p></li>
<li><p><strong>W</strong> – List of fields defining the vertical component of a VectorField, if F and V are the zonal and meridional components (default: None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="parcels.field.VectorField">
<em class="property">class </em><code class="sig-prename descclassname">parcels.field.</code><code class="sig-name descname">VectorField</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">U</span></em>, <em class="sig-param"><span class="n">V</span></em>, <em class="sig-param"><span class="n">W</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#VectorField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.VectorField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class VectorField stores 2 or 3 fields which defines together a vector field.
This enables to interpolate them as one single vector field in the kernels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the vector field</p></li>
<li><p><strong>U</strong> – field defining the zonal component</p></li>
<li><p><strong>V</strong> – field defining the meridional component</p></li>
<li><p><strong>W</strong> – field defining the vertical component (default: None)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="parcels.field.VectorField.spatial_c_grid_interpolation3D">
<code class="sig-name descname">spatial_c_grid_interpolation3D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ti</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">particle</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/field.html#VectorField.spatial_c_grid_interpolation3D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.field.VectorField.spatial_c_grid_interpolation3D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>V1</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>U0</p></td>
<td></td>
<td><p>U1</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>V0</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The interpolation is done in the following by
interpolating linearly U depending on the longitude coordinate and
interpolating linearly V depending on the latitude coordinate.
Curvilinear grids are treated properly, since the element is projected to a rectilinear parent element.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.gridset">
<span id="parcels-gridset-module"></span><h2>parcels.gridset module<a class="headerlink" href="#module-parcels.gridset" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.gridset.GridSet">
<em class="property">class </em><code class="sig-prename descclassname">parcels.gridset.</code><code class="sig-name descname">GridSet</code><a class="reference internal" href="_modules/parcels/gridset.html#GridSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.gridset.GridSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>GridSet class that holds the Grids on which the Fields are defined</p>
<dl class="py method">
<dt id="parcels.gridset.GridSet.dimrange">
<code class="sig-name descname">dimrange</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/gridset.html#GridSet.dimrange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.gridset.GridSet.dimrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns maximum value of a dimension (lon, lat, depth or time)
on ‘left’ side and minimum value on ‘right’ side for all grids
in a gridset. Useful for finding e.g. longitude range that
overlaps on all grids in a gridset</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.grid">
<span id="parcels-grid-module"></span><h2>parcels.grid module<a class="headerlink" href="#module-parcels.grid" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.grid.CGrid">
<em class="property">class </em><code class="sig-prename descclassname">parcels.grid.</code><code class="sig-name descname">CGrid</code><a class="reference internal" href="_modules/parcels/grid.html#CGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.grid.CGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_ctypes.Structure</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="parcels.grid.CurvilinearSGrid">
<em class="property">class </em><code class="sig-prename descclassname">parcels.grid.</code><code class="sig-name descname">CurvilinearSGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">depth</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'flat'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/grid.html#CurvilinearSGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.grid.CurvilinearSGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.grid.CurvilinearGrid</span></code></p>
<p>Curvilinear S Grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> – 2D array containing the longitude coordinates of the grid</p></li>
<li><p><strong>lat</strong> – 2D array containing the latitude coordinates of the grid</p></li>
<li><p><strong>depth</strong> – 4D (time-evolving) or 3D (time-independent) array containing the vertical coordinates of the grid,
which are s-coordinates.
s-coordinates can be terrain-following (sigma) or iso-density (rho) layers,
or any generalised vertical discretisation.
The depth of each node depends then on the horizontal position (lon, lat),
the number of the layer and the time is depth is a 4D array.
depth array is either a 4D array[xdim][ydim][zdim][tdim] or a 3D array[xdim][ydim[zdim].</p></li>
<li><p><strong>time</strong> – Vector containing the time coordinates of the grid</p></li>
<li><p><strong>time_origin</strong> – Time origin (TimeConverter object) of the time axis</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="parcels.grid.CurvilinearZGrid">
<em class="property">class </em><code class="sig-prename descclassname">parcels.grid.</code><code class="sig-name descname">CurvilinearZGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'flat'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/grid.html#CurvilinearZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.grid.CurvilinearZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.grid.CurvilinearGrid</span></code></p>
<p>Curvilinear Z Grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> – 2D array containing the longitude coordinates of the grid</p></li>
<li><p><strong>lat</strong> – 2D array containing the latitude coordinates of the grid</p></li>
<li><p><strong>depth</strong> – Vector containing the vertical coordinates of the grid, which are z-coordinates.
The depth of the different layers is thus constant.</p></li>
<li><p><strong>time</strong> – Vector containing the time coordinates of the grid</p></li>
<li><p><strong>time_origin</strong> – Time origin (TimeConverter object) of the time axis</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="parcels.grid.Grid">
<em class="property">class </em><code class="sig-prename descclassname">parcels.grid.</code><code class="sig-name descname">Grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">time_origin</span></em>, <em class="sig-param"><span class="n">mesh</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/grid.html#Grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.grid.Grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Grid class that defines a (spatial and temporal) grid on which Fields are defined</p>
<dl class="py method">
<dt id="parcels.grid.Grid.child_ctypes_struct">
<em class="property">property </em><code class="sig-name descname">child_ctypes_struct</code><a class="headerlink" href="#parcels.grid.Grid.child_ctypes_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ctypes struct object containing all relevant
pointers and sizes for this grid.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="parcels.grid.GridCode">
<em class="property">class </em><code class="sig-prename descclassname">parcels.grid.</code><code class="sig-name descname">GridCode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/grid.html#GridCode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.grid.GridCode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>An enumeration.</p>
</dd></dl>

<dl class="py class">
<dt id="parcels.grid.RectilinearSGrid">
<em class="property">class </em><code class="sig-prename descclassname">parcels.grid.</code><code class="sig-name descname">RectilinearSGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">depth</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'flat'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/grid.html#RectilinearSGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.grid.RectilinearSGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.grid.RectilinearGrid</span></code></p>
<dl class="simple">
<dt>Rectilinear S Grid. Same horizontal discretisation as a rectilinear z grid,</dt><dd><p>but with s vertical coordinates</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> – Vector containing the longitude coordinates of the grid</p></li>
<li><p><strong>lat</strong> – Vector containing the latitude coordinates of the grid</p></li>
<li><p><strong>depth</strong> – 4D (time-evolving) or 3D (time-independent) array containing the vertical coordinates of the grid,
which are s-coordinates.
s-coordinates can be terrain-following (sigma) or iso-density (rho) layers,
or any generalised vertical discretisation.
The depth of each node depends then on the horizontal position (lon, lat),
the number of the layer and the time is depth is a 4D array.
depth array is either a 4D array[xdim][ydim][zdim][tdim] or a 3D array[xdim][ydim[zdim].</p></li>
<li><p><strong>time</strong> – Vector containing the time coordinates of the grid</p></li>
<li><p><strong>time_origin</strong> – Time origin (TimeConverter object) of the time axis</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="parcels.grid.RectilinearZGrid">
<em class="property">class </em><code class="sig-prename descclassname">parcels.grid.</code><code class="sig-name descname">RectilinearZGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time_origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">'flat'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/grid.html#RectilinearZGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.grid.RectilinearZGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.grid.RectilinearGrid</span></code></p>
<p>Rectilinear Z Grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> – Vector containing the longitude coordinates of the grid</p></li>
<li><p><strong>lat</strong> – Vector containing the latitude coordinates of the grid</p></li>
<li><p><strong>depth</strong> – Vector containing the vertical coordinates of the grid, which are z-coordinates.
The depth of the different layers is thus constant.</p></li>
<li><p><strong>time</strong> – Vector containing the time coordinates of the grid</p></li>
<li><p><strong>time_origin</strong> – Time origin (TimeConverter object) of the time axis</p></li>
<li><p><strong>mesh</strong> – <p>String indicating the type of mesh coordinates and
units used during velocity interpolation:</p>
<ol class="arabic simple">
<li><p>spherical (default): Lat and lon in degree, with a
correction for zonal velocity U near the poles.</p></li>
<li><p>flat: No conversion, lat/lon are assumed to be in m.</p></li>
</ol>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-parcels.particle">
<span id="parcels-particle-module"></span><h2>parcels.particle module<a class="headerlink" href="#module-parcels.particle" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.particle.JITParticle">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particle.</code><code class="sig-name descname">JITParticle</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particle.html#JITParticle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particle.JITParticle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a></p>
<p>Particle class for JIT-based (Just-In-Time) Particle objects</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> – Initial longitude of particle</p></li>
<li><p><strong>lat</strong> – Initial latitude of particle</p></li>
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object to track this particle on</p></li>
<li><p><strong>dt</strong> – Execution timestep for this particle</p></li>
<li><p><strong>time</strong> – Current time of the particle</p></li>
</ul>
</dd>
</dl>
<p>Additional Variables can be added via the :Class Variable: objects</p>
<p>Users should use JITParticles for faster advection computation.</p>
</dd></dl>

<dl class="py class">
<dt id="parcels.particle.ScipyParticle">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particle.</code><code class="sig-name descname">ScipyParticle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">pid</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">cptr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particle.html#ScipyParticle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particle.ScipyParticle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particle._Particle</span></code></p>
<p>Class encapsulating the basic attributes of a particle,
to be executed in SciPy mode</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> – Initial longitude of particle</p></li>
<li><p><strong>lat</strong> – Initial latitude of particle</p></li>
<li><p><strong>depth</strong> – Initial depth of particle</p></li>
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object to track this particle on</p></li>
<li><p><strong>time</strong> – Current time of the particle</p></li>
</ul>
</dd>
</dl>
<p>Additional Variables can be added via the :Class Variable: objects</p>
</dd></dl>

<dl class="py class">
<dt id="parcels.particle.Variable">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particle.</code><code class="sig-name descname">Variable</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">dtype=&lt;class 'numpy.float32'&gt;</em>, <em class="sig-param">initial=0</em>, <em class="sig-param">to_write=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particle.html#Variable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particle.Variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Descriptor class that delegates data access to particle data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Variable name as used within kernels</p></li>
<li><p><strong>dtype</strong> – Data type (numpy.dtype) of the variable</p></li>
<li><p><strong>initial</strong> – Initial value of the variable. Note that this can also be a Field object,
which will then be sampled at the location of the particle</p></li>
<li><p><strong>to_write</strong> (<em>(</em><em>bool</em><em>, </em><em>'once'</em><em>, </em><em>optional</em><em>)</em>) – Boolean or ‘once’. Controls whether Variable is written to NetCDF file.
If to_write = ‘once’, the variable will be written as a time-independent 1D array</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="parcels.particle.Variable.is64bit">
<code class="sig-name descname">is64bit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particle.html#Variable.is64bit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particle.Variable.is64bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether variable is 64-bit</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.kernels.advection">
<span id="parcels-kernels-advection-module"></span><h2>parcels.kernels.advection module<a class="headerlink" href="#module-parcels.kernels.advection" title="Permalink to this headline">¶</a></h2>
<p>Collection of pre-built advection kernels</p>
<dl class="py function">
<dt id="parcels.kernels.advection.AdvectionAnalytical">
<code class="sig-prename descclassname">parcels.kernels.advection.</code><code class="sig-name descname">AdvectionAnalytical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advection.html#AdvectionAnalytical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advection.AdvectionAnalytical" title="Permalink to this definition">¶</a></dt>
<dd><p>Advection of particles using ‘analytical advection’ integration</p>
<p>Based on Ariane/TRACMASS algorithm, as detailed in e.g. Doos et al (<a class="reference external" href="https://doi.org/10.5194/gmd-10-1733-2017">https://doi.org/10.5194/gmd-10-1733-2017</a>).
Note that the time-dependent scheme is currently implemented with ‘intermediate timesteps’
(default 10 per model timestep) and not yet with the full analytical time integration</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.advection.AdvectionEE">
<code class="sig-prename descclassname">parcels.kernels.advection.</code><code class="sig-name descname">AdvectionEE</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advection.html#AdvectionEE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advection.AdvectionEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Advection of particles using Explicit Euler (aka Euler Forward) integration.</p>
<p>Function needs to be converted to Kernel object before execution</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.advection.AdvectionRK4">
<code class="sig-prename descclassname">parcels.kernels.advection.</code><code class="sig-name descname">AdvectionRK4</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advection.html#AdvectionRK4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advection.AdvectionRK4" title="Permalink to this definition">¶</a></dt>
<dd><p>Advection of particles using fourth-order Runge-Kutta integration.</p>
<p>Function needs to be converted to Kernel object before execution</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.advection.AdvectionRK45">
<code class="sig-prename descclassname">parcels.kernels.advection.</code><code class="sig-name descname">AdvectionRK45</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advection.html#AdvectionRK45"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advection.AdvectionRK45" title="Permalink to this definition">¶</a></dt>
<dd><p>Advection of particles using adadptive Runge-Kutta 4/5 integration.</p>
<p>Times-step dt is halved if error is larger than tolerance, and doubled
if error is smaller than 1/10th of tolerance, with tolerance set to
1e-5 * dt by default.</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.advection.AdvectionRK4_3D">
<code class="sig-prename descclassname">parcels.kernels.advection.</code><code class="sig-name descname">AdvectionRK4_3D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advection.html#AdvectionRK4_3D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advection.AdvectionRK4_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Advection of particles using fourth-order Runge-Kutta integration including vertical velocity.</p>
<p>Function needs to be converted to Kernel object before execution</p>
</dd></dl>

</div>
<div class="section" id="module-parcels.kernels.advectiondiffusion">
<span id="parcels-kernels-advectiondiffusion-module"></span><h2>parcels.kernels.advectiondiffusion module<a class="headerlink" href="#module-parcels.kernels.advectiondiffusion" title="Permalink to this headline">¶</a></h2>
<p>Collection of pre-built advection-diffusion kernels</p>
<p>See <a class="reference external" href="https://nbviewer.jupyter.org/github/OceanParcels/parcels/blob/master/parcels/examples/tutorial_diffusion.ipynb">this tutorial</a> for a detailed explanation</p>
<dl class="py function">
<dt id="parcels.kernels.advectiondiffusion.AdvectionDiffusionEM">
<code class="sig-prename descclassname">parcels.kernels.advectiondiffusion.</code><code class="sig-name descname">AdvectionDiffusionEM</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advectiondiffusion.html#AdvectionDiffusionEM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advectiondiffusion.AdvectionDiffusionEM" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel for 2D advection-diffusion, solved using the Euler-Maruyama
scheme (EM).</p>
<p>Assumes that fieldset has fields <cite>Kh_zonal</cite> and <cite>Kh_meridional</cite>
and variable <cite>fieldset.dres</cite>, setting the resolution for the central
difference gradient approximation. This should be (of the order of) the
local gridsize.</p>
<p>The Euler-Maruyama scheme is of strong order 0.5 and weak order 1.</p>
<p>The Wiener increment <cite>dW</cite> is normally distributed with zero
mean and a standard deviation of sqrt(dt).</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.advectiondiffusion.AdvectionDiffusionM1">
<code class="sig-prename descclassname">parcels.kernels.advectiondiffusion.</code><code class="sig-name descname">AdvectionDiffusionM1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advectiondiffusion.html#AdvectionDiffusionM1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advectiondiffusion.AdvectionDiffusionM1" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel for 2D advection-diffusion, solved using the Milstein scheme
at first order (M1).</p>
<p>Assumes that fieldset has fields <cite>Kh_zonal</cite> and <cite>Kh_meridional</cite>
and variable <cite>fieldset.dres</cite>, setting the resolution for the central
difference gradient approximation. This should be (of the order of) the
local gridsize.</p>
<p>This Milstein scheme is of strong and weak order 1, which is higher than the
Euler-Maruyama scheme. It experiences less spurious diffusivity by
including extra correction terms that are computationally cheap.</p>
<p>The Wiener increment <cite>dW</cite> is normally distributed with zero
mean and a standard deviation of sqrt(dt).</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.advectiondiffusion.DiffusionUniformKh">
<code class="sig-prename descclassname">parcels.kernels.advectiondiffusion.</code><code class="sig-name descname">DiffusionUniformKh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/advectiondiffusion.html#DiffusionUniformKh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.advectiondiffusion.DiffusionUniformKh" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel for simple 2D diffusion where diffusivity (Kh) is assumed uniform.</p>
<p>Assumes that fieldset has constant fields <cite>Kh_zonal</cite> and <cite>Kh_meridional</cite>.
These can be added via e.g.</p>
<blockquote>
<div><p>fieldset.add_constant_field(“Kh_zonal”, kh_zonal, mesh=mesh)
fieldset.add_constant_field(“Kh_meridional”, kh_meridional, mesh=mesh)</p>
</div></blockquote>
<p>where mesh is either ‘flat’ or ‘spherical’</p>
<p>This kernel assumes diffusivity gradients are zero and is therefore more efficient.
Since the perturbation due to diffusion is in this case isotropic independent, this
kernel contains no advection and can be used in combination with a seperate
advection kernel.</p>
<p>The Wiener increment <cite>dW</cite> is normally distributed with zero
mean and a standard deviation of sqrt(dt).</p>
</dd></dl>

</div>
<div class="section" id="module-parcels.kernels.EOSseawaterproperties">
<span id="parcels-kernels-eosseawaterproperties-module"></span><h2>parcels.kernels.EOSseawaterproperties module<a class="headerlink" href="#module-parcels.kernels.EOSseawaterproperties" title="Permalink to this headline">¶</a></h2>
<p>Collection of pre-built eos sea water property kernels</p>
<dl class="py function">
<dt id="parcels.kernels.EOSseawaterproperties.AdiabticTemperatureGradient">
<code class="sig-prename descclassname">parcels.kernels.EOSseawaterproperties.</code><code class="sig-name descname">AdiabticTemperatureGradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/EOSseawaterproperties.html#AdiabticTemperatureGradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.EOSseawaterproperties.AdiabticTemperatureGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates adiabatic temperature gradient as per UNESCO 1983 routines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>particle.S</strong> (<em>array_like</em>) – salinity [psu (PSS-78)]</p></li>
<li><p><strong>particle.T</strong> (<em>array_like</em>) – temperature [℃ (ITS-90)]</p></li>
<li><p><strong>particle.pressure</strong> (<em>array_like</em>) – pressure [db]</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>adiabatic temperature gradient [℃ db <sup>-1</sup>]</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id18"><span class="brackets">1</span></dt>
<dd><p>Fofonoff, P. and Millard, R.C. Jr UNESCO 1983. Algorithms for
computation of fundamental properties of seawater. UNESCO Tech. Pap. in
Mar. Sci., No. 44, 53 pp.
<a class="reference external" href="http://unesdoc.unesco.org/images/0005/000598/059832eb.pdf">http://unesdoc.unesco.org/images/0005/000598/059832eb.pdf</a></p>
</dd>
<dt class="label" id="id19"><span class="brackets">2</span></dt>
<dd><p>Bryden, H. 1973. New Polynomials for thermal expansion, adiabatic
temperature gradient and potential temperature of sea water. Deep-Sea
Res. Vol20,401-408. doi:10.1016/0011-7471(73)90063-6</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.EOSseawaterproperties.PressureFromLatDepth">
<code class="sig-prename descclassname">parcels.kernels.EOSseawaterproperties.</code><code class="sig-name descname">PressureFromLatDepth</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/EOSseawaterproperties.html#PressureFromLatDepth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.EOSseawaterproperties.PressureFromLatDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates pressure in dbars from depth in meters and latitude.</p>
<dl class="simple">
<dt>p<span class="classifier">array_like</span></dt><dd><p>pressure [db]</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id20"><span class="brackets">1</span></dt>
<dd><p>Saunders, Peter M., 1981: Practical Conversion of Pressure to Depth.
J. Phys. Oceanogr., 11, 573-574.
doi: 10.1175/1520-0485(1981)011&lt;0573:PCOPTD&gt;2.0.CO;2</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.EOSseawaterproperties.PtempFromTemp">
<code class="sig-prename descclassname">parcels.kernels.EOSseawaterproperties.</code><code class="sig-name descname">PtempFromTemp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/EOSseawaterproperties.html#PtempFromTemp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.EOSseawaterproperties.PtempFromTemp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates potential temperature as per UNESCO 1983 report.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>particle.S</strong> (<em>array_like</em>) – salinity [psu (PSS-78)]</p></li>
<li><p><strong>particle.T</strong> (<em>array_like</em>) – temperature [℃ (ITS-90)]</p></li>
<li><p><strong>particle.pressure</strong> (<em>array_like</em>) – pressure [db]</p></li>
<li><p><strong>fieldset.refpressure</strong> (<em>array_like</em>) – reference pressure [db], default = 0</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>potential temperature relative to PR [℃ (ITS-90)]</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id21"><span class="brackets">1</span></dt>
<dd><p>Fofonoff, P. and Millard, R.C. Jr UNESCO 1983. Algorithms for
computation of fundamental properties of seawater. UNESCO Tech. Pap. in
Mar. Sci., No. 44, 53 pp.  Eqn.(31) p.39.
<a class="reference external" href="http://unesdoc.unesco.org/images/0005/000598/059832eb.pdf">http://unesdoc.unesco.org/images/0005/000598/059832eb.pdf</a></p>
</dd>
<dt class="label" id="id22"><span class="brackets">2</span></dt>
<dd><p>Bryden, H. 1973. New Polynomials for thermal expansion, adiabatic
temperature gradient and potential temperature of sea water. Deep-Sea
Res. Vol20,401-408. doi:10.1016/0011-7471(73)90063-6</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="parcels.kernels.EOSseawaterproperties.TempFromPtemp">
<code class="sig-prename descclassname">parcels.kernels.EOSseawaterproperties.</code><code class="sig-name descname">TempFromPtemp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/EOSseawaterproperties.html#TempFromPtemp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.EOSseawaterproperties.TempFromPtemp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates temperature from potential temperature at the reference
pressure PR and in situ pressure P.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>particle.S</strong> (<em>array_like</em>) – salinity [psu (PSS-78)]</p></li>
<li><p><strong>particle.T</strong> (<em>array_like</em>) – potential temperature [℃ (ITS-90)]</p></li>
<li><p><strong>particle.pressure</strong> (<em>array_like</em>) – pressure [db]</p></li>
<li><p><strong>fieldset.refpressure</strong> (<em>array_like</em>) – reference pressure [db], default = 0</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>temperature [℃ (ITS-90)]</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id23"><span class="brackets">1</span></dt>
<dd><p>Fofonoff, P. and Millard, R.C. Jr UNESCO 1983. Algorithms for
computation of fundamental properties of seawater. UNESCO Tech. Pap. in
Mar. Sci., No. 44, 53 pp.  Eqn.(31) p.39.
<a class="reference external" href="http://unesdoc.unesco.org/images/0005/000598/059832eb.pdf">http://unesdoc.unesco.org/images/0005/000598/059832eb.pdf</a></p>
</dd>
<dt class="label" id="id24"><span class="brackets">2</span></dt>
<dd><p>Bryden, H. 1973. New Polynomials for thermal expansion, adiabatic
temperature gradient and potential temperature of sea water. Deep-Sea
Res.  Vol20,401-408. doi:10.1016/0011-7471(73)90063-6</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-parcels.kernels.TEOSseawaterdensity">
<span id="parcels-kernels-teosseawaterdensity-module"></span><h2>parcels.kernels.TEOSseawaterdensity module<a class="headerlink" href="#module-parcels.kernels.TEOSseawaterdensity" title="Permalink to this headline">¶</a></h2>
<p>Collection of pre-built sea water density kernels</p>
<dl class="py function">
<dt id="parcels.kernels.TEOSseawaterdensity.PolyTEOS10_bsq">
<code class="sig-prename descclassname">parcels.kernels.TEOSseawaterdensity.</code><code class="sig-name descname">PolyTEOS10_bsq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernels/TEOSseawaterdensity.html#PolyTEOS10_bsq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernels.TEOSseawaterdensity.PolyTEOS10_bsq" title="Permalink to this definition">¶</a></dt>
<dd><p># calculates density based on the polyTEOS10-bsq algorithm from Appendix A.2 of
# <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1463500315000566">https://www.sciencedirect.com/science/article/pii/S1463500315000566</a>
# requires fieldset.abs_salinity and fieldset.cons_temperature Fields in the fieldset
# and a particle.density Variable in the ParticleSet
#
# References:
#  Roquet, F., Madec, G., McDougall, T. J., Barker, P. M., 2014: Accurate
#   polynomial expressions for the density and specific volume of
#   seawater using the TEOS-10 standard. Ocean Modelling.
#  McDougall, T. J., D. R. Jackett, D. G. Wright and R. Feistel, 2003:
#   Accurate and computationally efficient algorithms for potential
#   temperature and density of seawater.  Journal of Atmospheric and
#   Oceanic Technology, 20, 730-741.</p>
</dd></dl>

</div>
<div class="section" id="module-parcels.codegenerator">
<span id="parcels-compilation-codegenerator-module"></span><h2>parcels.compilation.codegenerator module<a class="headerlink" href="#module-parcels.codegenerator" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="parcels-compilation-compiler-module">
<h2>parcels.compilation.compiler module<a class="headerlink" href="#parcels-compilation-compiler-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-parcels.kernel">
<span id="parcels-kernel-module"></span><h2>parcels.kernel module<a class="headerlink" href="#module-parcels.kernel" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.kernel.Kernel">
<em class="property">class </em><code class="sig-prename descclassname">parcels.kernel.</code><code class="sig-name descname">Kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">ptype</span></em>, <em class="sig-param"><span class="n">pyfunc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">funcname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">funccode</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">py_ast</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">funcvars</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">c_include</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">delete_cfiles</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernel.html#Kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernel.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Kernel object that encapsulates auto-generated code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – FieldSet object providing the field information</p></li>
<li><p><strong>ptype</strong> – PType object for the kernel particle</p></li>
<li><p><strong>delete_cfiles</strong> – Boolean whether to delete the C-files after compilation in JIT mode (default is True)</p></li>
</ul>
</dd>
</dl>
<p>Note: A Kernel is either created from a compiled &lt;function …&gt; object
or the necessary information (funcname, funccode, funcvars) is provided.
The py_ast argument may be derived from the code string, but for
concatenation, the merged AST plus the new header definition is required.</p>
<dl class="py method">
<dt id="parcels.kernel.Kernel.compile">
<code class="sig-name descname">compile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">compiler</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernel.html#Kernel.compile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernel.Kernel.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes kernel code to file and compiles it.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.kernel.Kernel.execute">
<code class="sig-name descname">execute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pset</span></em>, <em class="sig-param"><span class="n">endtime</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">recovery</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">output_file</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">execute_once</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernel.html#Kernel.execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernel.Kernel.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute this Kernel over a ParticleSet for several timesteps</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.kernel.Kernel.execute_jit">
<code class="sig-name descname">execute_jit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pset</span></em>, <em class="sig-param"><span class="n">endtime</span></em>, <em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernel.html#Kernel.execute_jit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernel.Kernel.execute_jit" title="Permalink to this definition">¶</a></dt>
<dd><p>Invokes JIT engine to perform the core update loop</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.kernel.Kernel.execute_python">
<code class="sig-name descname">execute_python</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pset</span></em>, <em class="sig-param"><span class="n">endtime</span></em>, <em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernel.html#Kernel.execute_python"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernel.Kernel.execute_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the core update loop via Python</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.kernel.Kernel.remove_deleted">
<code class="sig-name descname">remove_deleted</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pset</span></em>, <em class="sig-param"><span class="n">output_file</span></em>, <em class="sig-param"><span class="n">endtime</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernel.html#Kernel.remove_deleted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernel.Kernel.remove_deleted" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility to remove all particles that signalled deletion.</p>
<p>This version is generally applicable to all structures and collections</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.kernel.Kernel.remove_deleted_soa">
<code class="sig-name descname">remove_deleted_soa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pset</span></em>, <em class="sig-param"><span class="n">output_file</span></em>, <em class="sig-param"><span class="n">endtime</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/kernel.html#Kernel.remove_deleted_soa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.kernel.Kernel.remove_deleted_soa" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility to remove all particles that signalled deletion</p>
<p>This deletion function is targetted to index-addressable, random-access array-collections.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.particlefile">
<span id="parcels-particlefile-module"></span><h2>parcels.particlefile module<a class="headerlink" href="#module-parcels.particlefile" title="Permalink to this headline">¶</a></h2>
<p>Module controlling the writing of ParticleSets to NetCDF file</p>
<dl class="py class">
<dt id="parcels.particlefile.ParticleFile">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlefile.</code><code class="sig-name descname">ParticleFile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">particleset</span></em>, <em class="sig-param"><span class="n">outputdt</span><span class="o">=</span><span class="default_value">inf</span></em>, <em class="sig-param"><span class="n">write_ondelete</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">convert_at_end</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tempwritedir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pset_info</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise trajectory output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Basename of the output file</p></li>
<li><p><strong>particleset</strong> – ParticleSet to output</p></li>
<li><p><strong>outputdt</strong> – Interval which dictates the update frequency of file output
while ParticleFile is given as an argument of ParticleSet.execute()
It is either a timedelta object or a positive double.</p></li>
<li><p><strong>write_ondelete</strong> – Boolean to write particle data only when they are deleted. Default is False</p></li>
<li><p><strong>convert_at_end</strong> – Boolean to convert npy files to netcdf at end of run. Default is True</p></li>
<li><p><strong>tempwritedir</strong> – directories to write temporary files to during executing.
Default is out-XXXXXX where Xs are random capitals. Files for individual
processors are written to subdirectories 0, 1, 2 etc under tempwritedir</p></li>
<li><p><strong>pset_info</strong> – dictionary of info on the ParticleSet, stored in tempwritedir/XX/pset_info.npy,
used to create NetCDF file from npy-files.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.add_metadata">
<code class="sig-name descname">add_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">message</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.add_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.add_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Add metadata to <code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particleset.ParticleSet</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the metadata variabale</p></li>
<li><p><strong>message</strong> – message to be written</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delete_tempfiles</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the ParticleFile object by exporting and then deleting
the temporary npy files</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.delete_tempwritedir">
<code class="sig-name descname">delete_tempwritedir</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tempwritedir</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.delete_tempwritedir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.delete_tempwritedir" title="Permalink to this definition">¶</a></dt>
<dd><p>Deleted all temporary npy files</p>
<p>:param tempwritedir Optional path of the directory to delete</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.dump_dict_to_npy">
<code class="sig-name descname">dump_dict_to_npy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_dict</span></em>, <em class="sig-param"><span class="n">data_dict_once</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.dump_dict_to_npy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.dump_dict_to_npy" title="Permalink to this definition">¶</a></dt>
<dd><p>Buffer data to set of temporary numpy files, using np.save</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.dump_psetinfo_to_npy">
<code class="sig-name descname">dump_psetinfo_to_npy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.dump_psetinfo_to_npy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.dump_psetinfo_to_npy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.export">
<code class="sig-name descname">export</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.export"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports outputs in temporary NPY-files to NetCDF file</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.open_netcdf_file">
<code class="sig-name descname">open_netcdf_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_shape</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.open_netcdf_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.open_netcdf_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise NetCDF4.Dataset for trajectory output.
The output follows the format outlined in the Discrete Sampling Geometries
section of the CF-conventions:
<a class="reference external" href="http://cfconventions.org/cf-conventions/v1.6.0/cf-conventions.html#discrete-sampling-geometries">http://cfconventions.org/cf-conventions/v1.6.0/cf-conventions.html#discrete-sampling-geometries</a>
The current implementation is based on the NCEI template:
<a class="reference external" href="http://www.nodc.noaa.gov/data/formats/netcdf/v2.0/trajectoryIncomplete.cdl">http://www.nodc.noaa.gov/data/formats/netcdf/v2.0/trajectoryIncomplete.cdl</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_shape</strong> – shape of the variables in the NetCDF4 file</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.read_from_npy">
<code class="sig-name descname">read_from_npy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_list</span></em>, <em class="sig-param"><span class="n">time_steps</span></em>, <em class="sig-param"><span class="n">var</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.read_from_npy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.read_from_npy" title="Permalink to this definition">¶</a></dt>
<dd><p>Read NPY-files for one variable using a loop over all files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_list</strong> – List that  contains all file names in the output directory</p></li>
<li><p><strong>time_steps</strong> – Number of time steps that were written in out directory</p></li>
<li><p><strong>var</strong> – name of the variable to read</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlefile.ParticleFile.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pset</span></em>, <em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">deleted_only</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlefile.html#ParticleFile.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlefile.ParticleFile.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write all data from one time step to a temporary npy-file
using a python dictionary. The data is saved in the folder ‘out’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pset</strong> – ParticleSet object to write</p></li>
<li><p><strong>time</strong> – Time at which to write ParticleSet</p></li>
<li><p><strong>deleted_only</strong> – Flag to write only the deleted Particles</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.rng">
<span id="parcels-rng-module"></span><h2>parcels.rng module<a class="headerlink" href="#module-parcels.rng" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="parcels.rng.expovariate">
<code class="sig-prename descclassname">parcels.rng.</code><code class="sig-name descname">expovariate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lamb</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/rng.html#expovariate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.rng.expovariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randome float of an exponential distribution with parameter lamb</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.rng.normalvariate">
<code class="sig-prename descclassname">parcels.rng.</code><code class="sig-name descname">normalvariate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loc</span></em>, <em class="sig-param"><span class="n">scale</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/rng.html#normalvariate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.rng.normalvariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random float on normal distribution with mean <cite>loc</cite> and width <cite>scale</cite></p>
</dd></dl>

<dl class="py function">
<dt id="parcels.rng.randint">
<code class="sig-prename descclassname">parcels.rng.</code><code class="sig-name descname">randint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">low</span></em>, <em class="sig-param"><span class="n">high</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/rng.html#randint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.rng.randint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random int between <cite>low</cite> and <cite>high</cite></p>
</dd></dl>

<dl class="py function">
<dt id="parcels.rng.random">
<code class="sig-prename descclassname">parcels.rng.</code><code class="sig-name descname">random</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/rng.html#random"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.rng.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random float between 0. and 1.</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.rng.seed">
<code class="sig-prename descclassname">parcels.rng.</code><code class="sig-name descname">seed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seed</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/rng.html#seed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.rng.seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the seed for parcels internal RNG</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.rng.uniform">
<code class="sig-prename descclassname">parcels.rng.</code><code class="sig-name descname">uniform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">low</span></em>, <em class="sig-param"><span class="n">high</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/rng.html#uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.rng.uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random float between <cite>low</cite> and <cite>high</cite></p>
</dd></dl>

<dl class="py function">
<dt id="parcels.rng.vonmisesvariate">
<code class="sig-prename descclassname">parcels.rng.</code><code class="sig-name descname">vonmisesvariate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mu</span></em>, <em class="sig-param"><span class="n">kappa</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/rng.html#vonmisesvariate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.rng.vonmisesvariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randome float of a Von Mises distribution
with mean angle mu and concentration parameter kappa</p>
</dd></dl>

</div>
<div class="section" id="module-parcels.particlesets.baseparticleset">
<span id="parcels-particlesets-baseparticleset-module"></span><h2>parcels.particlesets.baseparticleset module<a class="headerlink" href="#module-parcels.particlesets.baseparticleset" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.baseparticleset.</code><code class="sig-name descname">BaseParticleSet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pclass</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lon</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repeatdt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pid_orig</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.particlesets.baseparticleset.NDCluster" title="parcels.particlesets.baseparticleset.NDCluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlesets.baseparticleset.NDCluster</span></code></a></p>
<p>Base ParticleSet.</p>
<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.Kernel">
<em class="property">abstract </em><code class="sig-name descname">Kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pyfunc</span></em>, <em class="sig-param"><span class="n">c_include</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">delete_cfiles</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.Kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method to convert a <cite>pyfunc</cite> into a <a class="reference internal" href="#parcels.kernel.Kernel" title="parcels.kernel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.kernel.Kernel</span></code></a> object
based on <cite>fieldset</cite> and <cite>ptype</cite> of the ParticleSet
:param delete_cfiles: Boolean whether to delete the C-files after compilation in JIT mode (default is True)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.ParticleFile">
<em class="property">abstract </em><code class="sig-name descname">ParticleFile</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.ParticleFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.ParticleFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper method to initialise a <a class="reference internal" href="#parcels.particlefile.ParticleFile" title="parcels.particlefile.ParticleFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlefile.ParticleFile</span></code></a>
object from the ParticleSet</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.cstruct">
<em class="property">abstract </em><code class="sig-name descname">cstruct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.cstruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.cstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>‘cstruct’ returns the ctypes mapping of the combined collections cstruct and the fieldset cstruct.
This depends on the specific structure in question.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.density">
<code class="sig-name descname">density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">field_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">particle_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">relative</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">area_scale</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to calculate the density of particles in a ParticleSet from their locations,
through a 2D histogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>field</strong> – Optional <a class="reference internal" href="#parcels.field.Field" title="parcels.field.Field"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.field.Field</span></code></a> object to calculate the histogram
on. Default is <cite>fieldset.U</cite></p></li>
<li><p><strong>particle_val</strong> – Optional numpy-array of values to weigh each particle with,
or string name of particle variable to use weigh particles with.
Default is None, resulting in a value of 1 for each particle</p></li>
<li><p><strong>relative</strong> – Boolean to control whether the density is scaled by the total
weight of all particles. Default is False</p></li>
<li><p><strong>area_scale</strong> – Boolean to control whether the density is scaled by the area
(in m^2) of each grid cell. Default is False</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.error_particles">
<em class="property">abstract property </em><code class="sig-name descname">error_particles</code><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.error_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an iterator over all particles that are in an error state.</p>
<p>This is a fallback implementation, it might be slow.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Collection iterator over error particles.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.execute">
<code class="sig-name descname">execute</code><span class="sig-paren">(</span><em class="sig-param">pyfunc=&lt;function AdvectionRK4&gt;</em>, <em class="sig-param">endtime=None</em>, <em class="sig-param">runtime=None</em>, <em class="sig-param">dt=1.0</em>, <em class="sig-param">moviedt=None</em>, <em class="sig-param">recovery=None</em>, <em class="sig-param">output_file=None</em>, <em class="sig-param">movie_background_field=None</em>, <em class="sig-param">verbose_progress=None</em>, <em class="sig-param">postIterationCallbacks=None</em>, <em class="sig-param">callbackdt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a given kernel function over the particle set for
multiple timesteps. Optionally also provide sub-timestepping
for particle output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyfunc</strong> – Kernel function to execute. This can be the name of a
defined Python function or a <a class="reference internal" href="#parcels.kernel.Kernel" title="parcels.kernel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.kernel.Kernel</span></code></a> object.
Kernels can be concatenated using the + operator</p></li>
<li><p><strong>endtime</strong> – End time for the timestepping loop.
It is either a datetime object or a positive double.</p></li>
<li><p><strong>runtime</strong> – Length of the timestepping loop. Use instead of endtime.
It is either a timedelta object or a positive double.</p></li>
<li><p><strong>dt</strong> – Timestep interval to be passed to the kernel.
It is either a timedelta object or a double.
Use a negative value for a backward-in-time simulation.</p></li>
<li><p><strong>moviedt</strong> – Interval for inner sub-timestepping (leap), which dictates
the update frequency of animation.
It is either a timedelta object or a positive double.
None value means no animation.</p></li>
<li><p><strong>output_file</strong> – <a class="reference internal" href="#parcels.particlefile.ParticleFile" title="parcels.particlefile.ParticleFile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particlefile.ParticleFile</span></code></a> object for particle output</p></li>
<li><p><strong>recovery</strong> – Dictionary with additional <cite>:mod:parcels.tools.error</cite>
recovery kernels to allow custom recovery behaviour in case of
kernel errors.</p></li>
<li><p><strong>movie_background_field</strong> – field plotted as background in the movie if moviedt is set.
‘vector’ shows the velocity as a vector field.</p></li>
<li><p><strong>verbose_progress</strong> – Boolean for providing a progress bar for the kernel execution loop.</p></li>
<li><p><strong>postIterationCallbacks</strong> – (Optional) Array of functions that are to be called after each iteration (post-process, non-Kernel)</p></li>
<li><p><strong>callbackdt</strong> – (Optional, in conjecture with ‘postIterationCallbacks) timestep inverval to (latestly) interrupt the running kernel and invoke post-iteration callbacks from ‘postIterationCallbacks’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.from_field">
<em class="property">classmethod </em><code class="sig-name descname">from_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">pclass</span></em>, <em class="sig-param"><span class="n">start_field</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'monte_carlo'</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repeatdt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.from_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.from_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the ParticleSet randomly drawn according to distribution from a field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object from which to sample velocity</p></li>
<li><p><strong>pclass</strong> – mod:<cite>parcels.particle.JITParticle</cite> or <a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a>
object that defines custom particle</p></li>
<li><p><strong>start_field</strong> – Field for initialising particles stochastically (horizontally)  according to the presented density field.</p></li>
<li><p><strong>size</strong> – Initial size of particle set</p></li>
<li><p><strong>mode</strong> – Type of random sampling. Currently only ‘monte_carlo’ is implemented</p></li>
<li><p><strong>depth</strong> – Optional list of initial depth values for particles. Default is 0m</p></li>
<li><p><strong>time</strong> – Optional start time value for particles. Default is fieldset.U.time[0]</p></li>
<li><p><strong>repeatdt</strong> – Optional interval (in seconds) on which to repeat the release of the ParticleSet</p></li>
<li><p><strong>lonlatdepth_dtype</strong> – Floating precision for lon, lat, depth particle coordinates.
It is either np.float32 or np.float64. Default is np.float32 if fieldset.U.interp_method is ‘linear’
and np.float64 if the interpolation method is ‘cgrid_velocity’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.from_line">
<em class="property">classmethod </em><code class="sig-name descname">from_line</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">pclass</span></em>, <em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">finish</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repeatdt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.from_line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.from_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the ParticleSet from start/finish coordinates with equidistant spacing
Note that this method uses simple numpy.linspace calls and does not take into account
great circles, so may not be a exact on a globe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object from which to sample velocity</p></li>
<li><p><strong>pclass</strong> – mod:<cite>parcels.particle.JITParticle</cite> or <a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a>
object that defines custom particle</p></li>
<li><p><strong>start</strong> – Starting point for initialisation of particles on a straight line.</p></li>
<li><p><strong>finish</strong> – End point for initialisation of particles on a straight line.</p></li>
<li><p><strong>size</strong> – Initial size of particle set</p></li>
<li><p><strong>depth</strong> – Optional list of initial depth values for particles. Default is 0m</p></li>
<li><p><strong>time</strong> – Optional start time value for particles. Default is fieldset.U.time[0]</p></li>
<li><p><strong>repeatdt</strong> – Optional interval (in seconds) on which to repeat the release of the ParticleSet</p></li>
<li><p><strong>lonlatdepth_dtype</strong> – Floating precision for lon, lat, depth particle coordinates.
It is either np.float32 or np.float64. Default is np.float32 if fieldset.U.interp_method is ‘linear’
and np.float64 if the interpolation method is ‘cgrid_velocity’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.from_list">
<em class="property">classmethod </em><code class="sig-name descname">from_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">pclass</span></em>, <em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repeatdt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.from_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.from_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the ParticleSet from lists of lon and lat</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object from which to sample velocity</p></li>
<li><p><strong>pclass</strong> – mod:<cite>parcels.particle.JITParticle</cite> or <a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a>
object that defines custom particle</p></li>
<li><p><strong>lon</strong> – List of initial longitude values for particles</p></li>
<li><p><strong>lat</strong> – List of initial latitude values for particles</p></li>
<li><p><strong>depth</strong> – Optional list of initial depth values for particles. Default is 0m</p></li>
<li><p><strong>time</strong> – Optional list of start time values for particles. Default is fieldset.U.time[0]</p></li>
<li><p><strong>repeatdt</strong> – Optional interval (in seconds) on which to repeat the release of the ParticleSet</p></li>
<li><p><strong>lonlatdepth_dtype</strong> – Floating precision for lon, lat, depth particle coordinates.
It is either np.float32 or np.float64. Default is np.float32 if fieldset.U.interp_method is ‘linear’
and np.float64 if the interpolation method is ‘cgrid_velocity’</p></li>
</ul>
</dd>
</dl>
<p>Other Variables can be initialised using further arguments (e.g. v=… for a Variable named ‘v’)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.from_particlefile">
<em class="property">abstract classmethod </em><code class="sig-name descname">from_particlefile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fieldset</span></em>, <em class="sig-param"><span class="n">pclass</span></em>, <em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">restart</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">restarttime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repeatdt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.from_particlefile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.from_particlefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the ParticleSet from a netcdf ParticleFile.
This creates a new ParticleSet based on locations of all particles written
in a netcdf ParticleFile at a certain time. Particle IDs are preserved if restart=True</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fieldset</strong> – <a class="reference internal" href="#parcels.fieldset.FieldSet" title="parcels.fieldset.FieldSet"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.FieldSet</span></code></a> object from which to sample velocity</p></li>
<li><p><strong>pclass</strong> – mod:<cite>parcels.particle.JITParticle</cite> or <a class="reference internal" href="#parcels.particle.ScipyParticle" title="parcels.particle.ScipyParticle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.particle.ScipyParticle</span></code></a>
object that defines custom particle</p></li>
<li><p><strong>filename</strong> – Name of the particlefile from which to read initial conditions</p></li>
<li><p><strong>restart</strong> – Boolean to signal if pset is used for a restart (default is True).
In that case, Particle IDs are preserved.</p></li>
<li><p><strong>restarttime</strong> – time at which the Particles will be restarted. Default is the last time written.
Alternatively, restarttime could be a time value (including np.datetime64) or
a callable function such as np.nanmin. The last is useful when running with dt &lt; 0.</p></li>
<li><p><strong>repeatdt</strong> – Optional interval (in seconds) on which to repeat the release of the ParticleSet</p></li>
<li><p><strong>lonlatdepth_dtype</strong> – Floating precision for lon, lat, depth particle coordinates.
It is either np.float32 or np.float64. Default is np.float32 if fieldset.U.interp_method is ‘linear’
and np.float64 if the interpolation method is ‘cgrid_velocity’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.monte_carlo_sample">
<em class="property">abstract classmethod </em><code class="sig-name descname">monte_carlo_sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_field</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'monte_carlo'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.monte_carlo_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.monte_carlo_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a starting field into a monte-carlo sample of lons and lats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>start_field</strong> – <code class="xref py py-mod docutils literal notranslate"><span class="pre">parcels.fieldset.Field</span></code> object for initialising particles stochastically (horizontally)  according to the presented density field.</p>
</dd>
</dl>
<p>returns list(lon), list(lat)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.num_error_particles">
<em class="property">property </em><code class="sig-name descname">num_error_particles</code><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.num_error_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of particles that are in an error state.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.baseparticleset.BaseParticleSet.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">with_particles</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">field</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">land</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">savefile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">animation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#BaseParticleSet.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.BaseParticleSet.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to ‘show’ a Parcels ParticleSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>with_particles</strong> – Boolean whether to show particles</p></li>
<li><p><strong>show_time</strong> – Time at which to show the ParticleSet</p></li>
<li><p><strong>field</strong> – Field to plot under particles (either None, a Field object, or ‘vector’)</p></li>
<li><p><strong>domain</strong> – dictionary (with keys ‘N’, ‘S’, ‘E’, ‘W’) defining domain to show</p></li>
<li><p><strong>projection</strong> – type of cartopy projection to use (default PlateCarree)</p></li>
<li><p><strong>land</strong> – Boolean whether to show land. This is ignored for flat meshes</p></li>
<li><p><strong>vmin</strong> – minimum colour scale (only in single-plot mode)</p></li>
<li><p><strong>vmax</strong> – maximum colour scale (only in single-plot mode)</p></li>
<li><p><strong>savefile</strong> – Name of a file to save the plot to</p></li>
<li><p><strong>animation</strong> – Boolean whether result is a single plot, or an animation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="parcels.particlesets.baseparticleset.NDCluster">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.baseparticleset.</code><code class="sig-name descname">NDCluster</code><a class="reference internal" href="_modules/parcels/particlesets/baseparticleset.html#NDCluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.baseparticleset.NDCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Interface.</p>
</dd></dl>

</div>
<div class="section" id="module-parcels.particlesets.collections">
<span id="parcels-particlesets-collections-module"></span><h2>parcels.particlesets.collections module<a class="headerlink" href="#module-parcels.particlesets.collections" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.particlesets.collections.Collection">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.collections.</code><code class="sig-name descname">Collection</code><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.add_collection">
<em class="property">abstract </em><code class="sig-name descname">add_collection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcollection</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.add_collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.add_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds another, differently structured ParticleCollection to this collection. This is done by, for example,
appending/adding the items of the other collection to this collection.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.add_same">
<em class="property">abstract </em><code class="sig-name descname">add_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.add_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.add_same" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds another, equi-structured ParticleCollection to this collection. This is done by concatenating
both collections. The fact that they are of the same ParticleCollection’s derivative simplifies
parsing and concatenation.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.add_single">
<em class="property">abstract </em><code class="sig-name descname">add_single</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.add_single"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.add_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Adding a single Particle to the collection - either as a ‘Particle; object in parcels itself, or
via its ParticleAccessor.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.append">
<em class="property">abstract </em><code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.append" title="Permalink to this definition">¶</a></dt>
<dd><p>This function appends a Particle (as object or via its accessor) to the end of a collection (‘end’ definition
depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,
sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the
end). For the collections, the function mapping equates to:</p>
<p>append(particle_obj) -&gt; add_single(particle_obj)</p>
<p>The function - in contrast to ‘push’ - does not return the index of the inserted object.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.clear">
<em class="property">abstract </em><code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>This function physically removes all elements of the collection, yielding an empty collection as result of the
operation.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the generic super-method to indicate obejct deletion of a specific object from this collection.</p>
<p>Comment/Annotation:
Functions for deleting multiple objects are more specialised than just a for-each loop of single-item deletion,
because certain data structures can delete multiple objects in-bulk faster with specialised function than making a
roundtrip per-item delete operation. Because of the sheer size of those containers and the resulting
performance demands, we need to make use of those specialised ‘del’ functions, where available.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.delete_by_ID">
<em class="property">abstract </em><code class="sig-name descname">delete_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.delete_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.delete_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>This method deletes a particle from the  the collection based on its ID. It does not return the deleted item.
Semantically, the function appears similar to the ‘remove’ operation. That said, the function in OceanParcels -
instead of directly deleting the particle - just raises the ‘deleted’ status flag for the indexed particle.
In result, the particle still remains in the collection. The functional interpretation of the ‘deleted’ status
is handled by ‘recovery’ dictionary during simulation execution.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.delete_by_index">
<em class="property">abstract </em><code class="sig-name descname">delete_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.delete_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.delete_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This method deletes a particle from the  the collection based on its index. It does not return the deleted item.
Semantically, the function appears similar to the ‘remove’ operation. That said, the function in OceanParcels -
instead of directly deleting the particle - just raises the ‘deleted’ status flag for the indexed particle.
In result, the particle still remains in the collection. The functional interpretation of the ‘deleted’ status
is handled by ‘recovery’ dictionary during simulation execution.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.empty">
<code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>This function retuns a boolean value, expressing if a collection is emoty (i.e. does not [anymore] contain any
elements) or not.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a generic super-method to get one- or multiple Particles (via their object, their ParticleAccessor,
their ID or their index) from the collection. Ideally, it just discerns between the types of the ‘other’
parameter, and then forwards the call to the related specific function.</p>
<p>Comment/Annotation:
Not all arguments have a sensible use-case in every datastructure, so some concrete classes may not implementat
all of them.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_collection">
<em class="property">abstract </em><code class="sig-name descname">get_collection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcollection</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection that are themselves stored in a ParticleCollection, which
is differently structured than this one. That means the other-collection has to be re-formatted first in an
intermediary format.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_multi_by_IDs">
<em class="property">abstract </em><code class="sig-name descname">get_multi_by_IDs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ids</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_multi_by_IDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_multi_by_IDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection based on their IDs. For collections where this removal
strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a get-
by-objects or get-by-indices scheme.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_multi_by_PyCollection_Particles">
<em class="property">abstract </em><code class="sig-name descname">get_multi_by_PyCollection_Particles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pycollectionp</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_multi_by_PyCollection_Particles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_multi_by_PyCollection_Particles" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection, which are themselves in common Python collections, such as
lists, dicts and numpy structures. We can either directly get the referred Particle instances (for internally-
ordered collections, e.g. ordered lists, sets, trees) or we may need to parse each instance for its index (for
random-access structures), which results in a considerable performance malus.</p>
<p>For collections where get-by-object incurs a performance malus, it is advisable to multi-get particles
by indices or IDs.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_multi_by_indices">
<em class="property">abstract </em><code class="sig-name descname">get_multi_by_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_multi_by_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_multi_by_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection based on their indices. This works best for random-access
collections (e.g. numpy’s ndarrays, dense matrices and dense arrays), whereas internally ordered collections
shall rather use a get-via-object-reference strategy.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_same">
<em class="property">abstract </em><code class="sig-name descname">get_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_same" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection that are themselves stored in another object of an equi-
structured ParticleCollection.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_single_by_ID">
<em class="property">abstract </em><code class="sig-name descname">get_single_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_single_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_single_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a (particle) object from the collection based on the object’s ID. For some collections,
this operation may involve a parsing of the whole list and translation of the object’s ID into an index  or an
object reference in the collection - which results in a significant performance malus.
In cases where a get-by-ID would result in a performance malus, it is highly-advisable to use a different
get function, e.g. get-by-index.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_single_by_index">
<em class="property">abstract </em><code class="sig-name descname">get_single_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_single_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_single_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a (particle) object from the collection based on its index within the collection. For
collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a
translation of the index into the specific object reference in the collection - or (if unavoidable) the
translation of the collection from a none-indexable, none-random-access structure into an indexable structure.
In cases where a get-by-index would result in a performance malus, it is highly-advisable to use a different
get function, e.g. get-by-ID.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.get_single_by_object">
<em class="property">abstract </em><code class="sig-name descname">get_single_by_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.get_single_by_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.get_single_by_object" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a (particle) object from the collection based on its actual object. For collections that
are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function
would involve a parsing of the whole list and translation of the object into an index in the collection - which
results in a significant performance malus.
In cases where a get-by-object would result in a performance malus, it is highly-advisable to use a different
get function, e.g. get-by-index or get-by-ID.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.insert">
<em class="property">abstract </em><code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>This function allows to ‘insert’ a Particle (as object or via its accessor) into this collection. This method
needs to be specified to each collection individually. Some collections (e.g. unordered list) allow to define
the index where the object is to be inserted. Some collections can optionally insert an object at a specific
position - at a significant speed- and memory malus cost (e.g. vectors, arrays, dense matrices). Some
collections that manage a specified indexing order internally (e.g. ordered lists, sets, trees), and thus
have no use for an ‘index’ parameter. For those collections with an internally-enforced order, the function
mapping equates to:</p>
<p>insert(obj) -&gt; add_single(obj)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.iterator">
<code class="sig-name descname">iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.iterator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is an explicit object-return of a forward-iterator over this collection. If this iterator is
persistent or re-created upon call depends on the specific implementation of the ‘__iter__’ function.</p>
<p>This function is an explicit forward to the Collection::__iter__() member function.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.merge">
<em class="property">abstract </em><code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.merge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>This function merge two strictly equally-structured ParticleCollections into one. This can be, for example,
quite handy to merge two particle subsets that - due to continuous removal - become too small to be effective.</p>
<p>On the other hand, this function can also internally merge individual particles that are tagged by status as
being ‘merged’ (see the particle status for information on that).</p>
<p>In order to distinguish both use cases, we can evaluate the ‘same_class’ parameter. In cases where this is
‘None’, the merge operation semantically refers to an internal merge of individual particles - otherwise,
it performs a 2-collection merge.</p>
<p>Comment: the function can be simplified later by pre-evaluating the function parameter and then reference
the individual, specific functions for internal- or external merge.</p>
<p>The function shall return the merged ParticleCollection.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>This function pops a Particle (as object or via its accessor) from a collection.</p>
<p>This function removes the particle and then returns it.</p>
<p>Comment/Annotation:
Functions for popping multiple objects are more specialised than just a for-each loop of single-item pop,
because certain data structures can pop multiple objects faster with specialised function than making a
roundtrip per-item check-and-pop operation. Because of the sheer size of those containers and the resulting
performance demands, we need to make use of those specialised ‘pop’ functions, where available.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.pop_multi_by_IDs">
<em class="property">abstract </em><code class="sig-name descname">pop_multi_by_IDs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ids</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.pop_multi_by_IDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.pop_multi_by_IDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particles with the IDs registered in ‘ids’, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).
If Particles cannot be retrieved (e.g. because the IDs are not available), returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.pop_multi_by_indices">
<em class="property">abstract </em><code class="sig-name descname">pop_multi_by_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.pop_multi_by_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.pop_multi_by_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particles with the indices registered in ‘indices’, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).
If indices is None -&gt; Particle cannot be retrieved -&gt; Assert-Error and return None
If index is None, return last item (-1);
If index &lt; 0: return from ‘end’ of collection.
If index in ‘indices’ is out of bounds, throws and OutOfRangeException.
If Particles cannot be retrieved, returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.pop_single_by_ID">
<em class="property">abstract </em><code class="sig-name descname">pop_single_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.pop_single_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.pop_single_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particle with ID ‘id’, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).
If Particle cannot be retrieved (e.g. because the ID is not available), returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.pop_single_by_index">
<em class="property">abstract </em><code class="sig-name descname">pop_single_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.pop_single_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.pop_single_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particle at index ‘index’, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).
If index is None, return last item (-1);
If index &lt; 0: return from ‘end’ of collection.
If index is out of bounds, throws and OutOfRangeException.
If Particle cannot be retrieved, returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.push">
<em class="property">abstract </em><code class="sig-name descname">push</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.push"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.push" title="Permalink to this definition">¶</a></dt>
<dd><p>This function pushes a Particle (as object or via its accessor) to the end of a collection (‘end’ definition
depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,
sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the
end). For the collections, the function mapping equates to:</p>
<p>int32 push(particle_obj) -&gt; add_single(particle_obj); return -1;</p>
<p>This function further returns the index, at which position the Particle has been inserted. By definition,
the index is positive, thus: a return of ‘-1’ indicates push failure, NOT the last position in the collection.
Furthermore, collections that do not work on an index-preserving manner also return ‘-1’.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a generic super-method to remove one- or multiple Particles (via their object, their ParticleAccessor,
their ID or their index) from the collection. Ideally, it just discerns between the types of the ‘other’
parameter, and then forwards the call to the related specific function.</p>
<p>Comment/Annotation:
Functions for removing multiple objects are more specialised than just a for-each loop of single-item removal,
because certain data structures can remove multiple objects faster with specialised function than making a
roundtrip per-item check-and-remove operation. Because of the sheer size of those containers and the resulting
performance demands, we need to make use of those specialised ‘remove’ functions, where available.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_collection">
<em class="property">abstract </em><code class="sig-name descname">remove_collection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcollection</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection that are themselves stored in a ParticleCollection, which
is differently structured than this one. Tht means the removal first requires the removal-collection to be re-
formatted in an intermediary format, before executing the removal.
That said, this method should still be at least as efficient as a removal via common Python collections (i.e.
lists, dicts, numpy’s nD arrays &amp; dense arrays). Despite this, due to the reformatting, in some cases it may
be more efficient to remove items then rather by IDs oder indices.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_multi_by_IDs">
<em class="property">abstract </em><code class="sig-name descname">remove_multi_by_IDs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ids</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_multi_by_IDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_multi_by_IDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection based on their IDs. For collections where this removal
strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a removal-
by-objects or removal-by-indices scheme.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_multi_by_PyCollection_Particles">
<em class="property">abstract </em><code class="sig-name descname">remove_multi_by_PyCollection_Particles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pycollectionp</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_multi_by_PyCollection_Particles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_multi_by_PyCollection_Particles" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection, which are themselves in common Python collections, such as
lists, dicts and numpy structures. In order to perform the removal, we can either directly remove the referred
Particle instances (for internally-ordered collections, e.g. ordered lists, sets, trees) or we may need to parse
each instance for its index (for random-access structures), which results in a considerable performance malus.</p>
<p>For collections where removal-by-object incurs a performance malus, it is advisable to multi-remove particles
by indices or IDs.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_multi_by_indices">
<em class="property">abstract </em><code class="sig-name descname">remove_multi_by_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_multi_by_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_multi_by_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection based on their indices. This works best for random-access
collections (e.g. numpy’s ndarrays, dense matrices and dense arrays), whereas internally ordered collections
shall rather use a removal-via-object-reference strategy.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_same">
<em class="property">abstract </em><code class="sig-name descname">remove_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_same" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection that are themselves stored in another object of an equi-
structured ParticleCollection. As the structures of both collections are the same, a more efficient M-in-N
removal can be applied without an in-between reformatting.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_single_by_ID">
<em class="property">abstract </em><code class="sig-name descname">remove_single_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_single_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_single_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes a (particle) object from the collection based on the object’s ID. For some collections,
this operation may involve a parsing of the whole list and translation of the object’s ID into an index  or an
object reference in the collection in order to perform the removal - which results in a significant performance
malus.
In cases where a removal-by-ID would result in a performance malus, it is highly-advisable to use a different
removal functions, e.g. remove-by-object or remove-by-index.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_single_by_index">
<em class="property">abstract </em><code class="sig-name descname">remove_single_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_single_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_single_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes a (particle) object from the collection based on its index within the collection. For
collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a
translation of the index into the specific object reference in the collection - or (if unavoidable) the
translation of the collection from a none-indexable, none-random-access structure into an indexable structure,
and then perform the removal.
In cases where a removal-by-index would result in a performance malus, it is highly-advisable to use a different
removal functions, e.g. remove-by-object or remove-by-ID.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.remove_single_by_object">
<em class="property">abstract </em><code class="sig-name descname">remove_single_by_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.remove_single_by_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.remove_single_by_object" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes a (particle) object from the collection based on its actual object. For collections that
are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function
would involves a parsing of the whole list and translation of the object into an index in the collection to
perform the removal - which results in a significant performance malus.
In cases where a removal-by-object would result in a performance malus, it is highly-advisable to use a different
removal functions, e.g. remove-by-index or remove-by-ID.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.reverse_iterator">
<code class="sig-name descname">reverse_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.reverse_iterator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.reverse_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is an explicit object-return of a backward-iterator over this collection. If this iterator is
persistent or re-created upon call depends on the specific implementation of the ‘__reversed__’ function.</p>
<p>This function is an explicit forward to the Collection::__reversed__() member function.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.split">
<em class="property">abstract </em><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.split" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits this collection into two disect equi-structured collections. The reason for it can, for
example, be that the set exceeds a pre-defined maximum number of elements, which for performance reasons
mandates a split.</p>
<p>On the other hand, this function can also internally split individual particles that are tagged byt status as
to be ‘split’ (see the particle status for information on that).</p>
<p>In order to distinguish both use cases, we can evaluate the ‘indices’ parameter. In cases where this is
‘None’, the split operation semantically refers to an internal split of individual particles - otherwise,
it performs a collection-split.</p>
<p>Comment: the function can be simplified later by pre-evaluating the function parameter and then reference
the individual, specific functions for element- or collection split.</p>
<p>The function shall return the newly created or extended Particle collection, i.e. either the collection that
results from a collection split or this very collection, containing the newly-split particles.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.Collection.toArray">
<em class="property">abstract </em><code class="sig-name descname">toArray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#Collection.toArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.Collection.toArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This function converts (or: transforms; reformats; translates) this collection into an array-like structure
(e.g. Python list or numpy nD array) that can be addressed by index. In the common case of ‘no ID recovery’,
the global ID and the index match exactly.</p>
<p>While this function may be very convenient for may users, it is STRONGLY DISADVISED to use the function to
often, and the performance- and memory overhead malus may be exceed any speed-up one could get from optimised
data structures - in fact, for large collections with an implicit-order structure (i.e. ordered lists, sets,
trees, etc.), this may be ‘the most constly’ function in any kind of simulation.</p>
<p>It can be - though - useful at the final stage of a simulation to dump the results to disk.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="parcels.particlesets.collections.ParticleCollection">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.collections.</code><code class="sig-name descname">ParticleCollection</code><a class="reference internal" href="_modules/parcels/particlesets/collections.html#ParticleCollection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.particlesets.collections.Collection" title="parcels.particlesets.collections.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlesets.collections.Collection</span></code></a></p>
<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.cstruct">
<em class="property">abstract </em><code class="sig-name descname">cstruct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#ParticleCollection.cstruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.cstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>‘cstruct’ returns the ctypes mapping of the particle data. This depends on the specific structure in question.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.data">
<em class="property">property </em><code class="sig-name descname">data</code><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.data" title="Permalink to this definition">¶</a></dt>
<dd><p>‘data’ is a reference to the actual barebone-storage of the particle data, and thus depends directly on the
specific collection in question.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.lonlatdepth_dtype">
<em class="property">property </em><code class="sig-name descname">lonlatdepth_dtype</code><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.lonlatdepth_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>‘lonlatdepth_dtype’ stores the numeric data type that is used to represent the lon, lat and depth of a particle.
This can be either ‘float32’ (default) or ‘float64’</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.particle_data">
<em class="property">property </em><code class="sig-name descname">particle_data</code><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.particle_data" title="Permalink to this definition">¶</a></dt>
<dd><p>‘particle_data’ is a reference to the actual barebone-storage of the particle data, and thus depends directly on the
specific collection in question. This property is just available for convenience and backward-compatibility, and
this returns the same as ‘data’.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.pclass">
<em class="property">property </em><code class="sig-name descname">pclass</code><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.pclass" title="Permalink to this definition">¶</a></dt>
<dd><p>‘pclass’ stores the actual class type of the particles allocated and managed in this collection</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.ptype">
<em class="property">property </em><code class="sig-name descname">ptype</code><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.ptype" title="Permalink to this definition">¶</a></dt>
<dd><p>‘ptype’ returns an instance of the particular type of class ‘ParticleType’ of the particle class of the particles
in this collection.</p>
<p>basically:
pytpe -&gt; pclass().getPType()</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.pu_centers">
<em class="property">property </em><code class="sig-name descname">pu_centers</code><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.pu_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>The ‘pu_centers” is an array of 2D/3D vectors storing the center of each cluster-of-particle partion that
is handled by the respective PU. Storing the centers allows us to only run the initial kMeans segmentation
once and then, on later particle additions, just (i) makes a closest-distance calculation, (ii) attaches the
new particle to the closest cluster and (iii) updates the new cluster center. The last part may require at some
point to merge overlaying clusters and them split them again in equi-sized partions.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.pu_indicators">
<em class="property">property </em><code class="sig-name descname">pu_indicators</code><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.pu_indicators" title="Permalink to this definition">¶</a></dt>
<dd><p>The ‘pu_indicator’ is an [array or dictionary]-of-indicators, where each indicator entry tells per item
(i.e. particle) in the collection to which processing unit (PU) in a parallelised setup it belongs to.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.set_variable_write_status">
<em class="property">abstract </em><code class="sig-name descname">set_variable_write_status</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">write_status</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#ParticleCollection.set_variable_write_status"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.set_variable_write_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to set the write status of a Variable
:param var: Name of the variable (string)
:param status: Write status of the variable (True, False or ‘once’)</p>
<blockquote>
<div><p>This function depends on the specific collection in question and thus needs to be specified in specific
derivatives classes.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collections.ParticleCollection.toDictionary">
<em class="property">abstract </em><code class="sig-name descname">toDictionary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collections.html#ParticleCollection.toDictionary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collections.ParticleCollection.toDictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all Particle data from one time step to a python dictionary.
:param pfile: ParticleFile object requesting the conversion
:param time: Time at which to write ParticleSet
:param deleted_only: Flag to write only the deleted Particles
returns two dictionaries: one for all variables to be written each outputdt,</p>
<blockquote>
<div><p>and one for all variables to be written once</p>
<p>This function depends on the specific collection in question and thus needs to be specified in specific
derivatives classes.</p>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.particlesets.collectionsoa">
<span id="parcels-particlesets-collectionsoa-module"></span><h2>parcels.particlesets.collectionsoa module<a class="headerlink" href="#module-parcels.particlesets.collectionsoa" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.particlesets.collectionsoa.ParticleAccessorSOA">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.collectionsoa.</code><code class="sig-name descname">ParticleAccessorSOA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcoll</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleAccessorSOA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleAccessorSOA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.particlesets.iterators.BaseParticleAccessor" title="parcels.particlesets.iterators.BaseParticleAccessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlesets.iterators.BaseParticleAccessor</span></code></a></p>
<p>Wrapper that provides access to particle data in the collection,
as if interacting with the particle itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pcoll</strong> – ParticleCollection that the represented particle
belongs to.</p></li>
<li><p><strong>index</strong> – The index at which the data for the represented
particle is stored in the corresponding data arrays
of the ParticleCollecion.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionIteratorSOA">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.collectionsoa.</code><code class="sig-name descname">ParticleCollectionIteratorSOA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcoll</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">subset</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionIteratorSOA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionIteratorSOA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.particlesets.iterators.BaseParticleCollectionIterator" title="parcels.particlesets.iterators.BaseParticleCollectionIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlesets.iterators.BaseParticleCollectionIterator</span></code></a></p>
<p>Iterator for looping over the particles in the ParticleCollection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pcoll</strong> – ParticleCollection that stores the particles.</p></li>
<li><p><strong>reverse</strong> – Flag to indicate reverse iteration (i.e. starting at
the largest index, instead of the smallest).</p></li>
<li><p><strong>subset</strong> – Subset of indices to iterate over, this allows the
creation of an iterator that represents part of the
collection.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionIteratorSOA.current">
<em class="property">property </em><code class="sig-name descname">current</code><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionIteratorSOA.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ParticleAccessor for the particle that the iteration
is currently at.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.collectionsoa.</code><code class="sig-name descname">ParticleCollectionSOA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pclass</span></em>, <em class="sig-param"><span class="n">lon</span></em>, <em class="sig-param"><span class="n">lat</span></em>, <em class="sig-param"><span class="n">depth</span></em>, <em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">lonlatdepth_dtype</span></em>, <em class="sig-param"><span class="n">pid_orig</span></em>, <em class="sig-param"><span class="n">partitions</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ngrid</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.particlesets.collections.ParticleCollection" title="parcels.particlesets.collections.ParticleCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.particlesets.collections.ParticleCollection</span></code></a></p>
<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_collection">
<code class="sig-name descname">add_collection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcollection</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.add_collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds another, differently structured ParticleCollection to this collection. This is done by, for example,
appending/adding the items of the other collection to this collection.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_same">
<code class="sig-name descname">add_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.add_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_same" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds another, equi-structured ParticleCollection to this collection. This is done by concatenating
both collections. The fact that they are of the same ParticleCollection’s derivative simplifies
parsing and concatenation.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_single">
<code class="sig-name descname">add_single</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.add_single"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.add_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Adding a single Particle to the collection - either as a ‘Particle; object in parcels itself, or
via its ParticleAccessor.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.append" title="Permalink to this definition">¶</a></dt>
<dd><p>This function appends a Particle (as object or via its accessor) to the end of a collection (‘end’ definition
depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,
sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the
end). For the collections, the function mapping equates to:</p>
<p>append(particle_obj) -&gt; add_single(particle_obj)</p>
<p>The function - in contrast to ‘push’ - does not return the index of the inserted object.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>This function physically removes all elements of the collection, yielding an empty collection as result of the
operation.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.cstruct">
<code class="sig-name descname">cstruct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.cstruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.cstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>‘cstruct’ returns the ctypes mapping of the particle data. This depends on the specific structure in question.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.delete_by_ID">
<code class="sig-name descname">delete_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.delete_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.delete_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>This method deletes a particle from the  the collection based on its ID. It does not return the deleted item.
Semantically, the function appears similar to the ‘remove’ operation. That said, the function in OceanParcels -
instead of directly deleting the particle - just raises the ‘deleted’ status flag for the indexed particle.
In result, the particle still remains in the collection. The functional interpretation of the ‘deleted’ status
is handled by ‘recovery’ dictionary during simulation execution.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.delete_by_index">
<code class="sig-name descname">delete_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.delete_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.delete_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This method deletes a particle from the  the collection based on its index. It does not return the deleted item.
Semantically, the function appears similar to the ‘remove’ operation. That said, the function in OceanParcels -
instead of directly deleting the particle - just raises the ‘deleted’ status flag for the indexed particle.
In result, the particle still remains in the collection. The functional interpretation of the ‘deleted’ status
is handled by ‘recovery’ dictionary during simulation execution.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_collection">
<code class="sig-name descname">get_collection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcollection</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection that are themselves stored in a ParticleCollection, which
is differently structured than this one. That means the other-collection has to be re-formatted first in an
intermediary format.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_IDs">
<code class="sig-name descname">get_multi_by_IDs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ids</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_multi_by_IDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_IDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection based on their IDs. For collections where this removal
strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a get-
by-objects or get-by-indices scheme.</p>
<p>Note that this implementation assumes that IDs of particles are strictly increasing with increasing index. So
a particle with a larger index will always have a larger ID as well. The assumption often holds for this
datastructure as new particles always get a larger ID than any existing particle (IDs are not recycled)
and their data are appended at the end of the list (largest index). This allows for the use of binary search
in the look-up. The collection maintains a <cite>sorted</cite> flag to indicate whether this assumption holds.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_PyCollection_Particles">
<code class="sig-name descname">get_multi_by_PyCollection_Particles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pycollectionp</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_multi_by_PyCollection_Particles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_PyCollection_Particles" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection, which are themselves in common Python collections, such as
lists, dicts and numpy structures. We can either directly get the referred Particle instances (for internally-
ordered collections, e.g. ordered lists, sets, trees) or we may need to parse each instance for its index (for
random-access structures), which results in a considerable performance malus.</p>
<p>For collections where get-by-object incurs a performance malus, it is advisable to multi-get particles
by indices or IDs.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_indices">
<code class="sig-name descname">get_multi_by_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_multi_by_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_multi_by_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection based on their indices. This works best for random-access
collections (e.g. numpy’s ndarrays, dense matrices and dense arrays), whereas internally ordered collections
shall rather use a get-via-object-reference strategy.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_same">
<code class="sig-name descname">get_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_same" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets particles from this collection that are themselves stored in another object of an equi-
structured ParticleCollection.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_ID">
<code class="sig-name descname">get_single_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_single_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a (particle) object from the collection based on the object’s ID. For some collections,
this operation may involve a parsing of the whole list and translation of the object’s ID into an index  or an
object reference in the collection - which results in a significant performance malus.
In cases where a get-by-ID would result in a performance malus, it is highly-advisable to use a different
get function, e.g. get-by-index.</p>
<p>This function uses binary search if we know the ID list to be sorted, and linear search otherwise. We assume
IDs are unique.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_index">
<code class="sig-name descname">get_single_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_single_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a (particle) object from the collection based on its index within the collection. For
collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a
translation of the index into the specific object reference in the collection - or (if unavoidable) the
translation of the collection from a none-indexable, none-random-access structure into an indexable structure.
In cases where a get-by-index would result in a performance malus, it is highly-advisable to use a different
get function, e.g. get-by-ID.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_object">
<code class="sig-name descname">get_single_by_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.get_single_by_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.get_single_by_object" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets a (particle) object from the collection based on its actual object. For collections that
are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function
would involve a parsing of the whole list and translation of the object into an index in the collection - which
results in a significant performance malus.
In cases where a get-by-object would result in a performance malus, it is highly-advisable to use a different
get function, e.g. get-by-index or get-by-ID.</p>
<p>In this specific implementation, we cannot look for the object
directly, so we will look for one of its properties (the ID) that
has the nice property of being stored in an ordered list (if the
collection is sorted)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>This function allows to ‘insert’ a Particle (as object or via its accessor) into this collection. This method
needs to be specified to each collection individually. Some collections (e.g. unordered list) allow to define
the index where the object is to be inserted. Some collections can optionally insert an object at a specific
position - at a significant speed- and memory malus cost (e.g. vectors, arrays, dense matrices). Some
collections that manage a specified indexing order internally (e.g. ordered lists, sets, trees), and thus
have no use for an ‘index’ parameter. For those collections with an internally-enforced order, the function
mapping equates to:</p>
<p>insert(obj) -&gt; add_single(obj)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.merge">
<code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.merge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>This function merge two strictly equally-structured ParticleCollections into one. This can be, for example,
quite handy to merge two particle subsets that - due to continuous removal - become too small to be effective.</p>
<p>On the other hand, this function can also internally merge individual particles that are tagged by status as
being ‘merged’ (see the particle status for information on that).</p>
<p>In order to distinguish both use cases, we can evaluate the ‘same_class’ parameter. In cases where this is
‘None’, the merge operation semantically refers to an internal merge of individual particles - otherwise,
it performs a 2-collection merge.</p>
<p>Comment: the function can be simplified later by pre-evaluating the function parameter and then reference
the individual, specific functions for internal- or external merge.</p>
<p>The function shall return the merged ParticleCollection.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_multi_by_IDs">
<code class="sig-name descname">pop_multi_by_IDs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ids</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.pop_multi_by_IDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_multi_by_IDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particles with the IDs registered in ‘ids’, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).
If Particles cannot be retrieved (e.g. because the IDs are not available), returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_multi_by_indices">
<code class="sig-name descname">pop_multi_by_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.pop_multi_by_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_multi_by_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particles with the indices registered in ‘indices’, removes the Particles from the Collection and returns the Particles (or: their ParticleAccessors).
If indices is None -&gt; Particle cannot be retrieved -&gt; Assert-Error and return None
If index is None, return last item (-1);
If index &lt; 0: return from ‘end’ of collection.
If index in ‘indices’ is out of bounds, throws and OutOfRangeException.
If Particles cannot be retrieved, returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_single_by_ID">
<code class="sig-name descname">pop_single_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.pop_single_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_single_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particle with ID ‘id’, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).
If Particle cannot be retrieved (e.g. because the ID is not available), returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_single_by_index">
<code class="sig-name descname">pop_single_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.pop_single_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.pop_single_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for Particle at index ‘index’, removes that Particle from the Collection and returns that Particle (or: ParticleAccessor).
If index is None, return last item (-1);
If index &lt; 0: return from ‘end’ of collection.
If index is out of bounds, throws and OutOfRangeException.
If Particle cannot be retrieved, returns None.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.push">
<code class="sig-name descname">push</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.push"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.push" title="Permalink to this definition">¶</a></dt>
<dd><p>This function pushes a Particle (as object or via its accessor) to the end of a collection (‘end’ definition
depends on the specific collection itself). For collections with an inherent indexing order (e.g. ordered lists,
sets, trees), the function just includes the object at its pre-defined position (i.e. not necessarily at the
end). For the collections, the function mapping equates to:</p>
<p>int32 push(particle_obj) -&gt; add_single(particle_obj); return -1;</p>
<p>This function further returns the index, at which position the Particle has been inserted. By definition,
the index is positive, thus: a return of ‘-1’ indicates push failure, NOT the last position in the collection.
Furthermore, collections that do not work on an index-preserving manner also return ‘-1’.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_collection">
<code class="sig-name descname">remove_collection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcollection</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection that are themselves stored in a ParticleCollection, which
is differently structured than this one. Tht means the removal first requires the removal-collection to be re-
formatted in an intermediary format, before executing the removal.
That said, this method should still be at least as efficient as a removal via common Python collections (i.e.
lists, dicts, numpy’s nD arrays &amp; dense arrays). Despite this, due to the reformatting, in some cases it may
be more efficient to remove items then rather by IDs oder indices.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_IDs">
<code class="sig-name descname">remove_multi_by_IDs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ids</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_multi_by_IDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_IDs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection based on their IDs. For collections where this removal
strategy would require a collection transformation or by-ID parsing, it is advisable to rather apply a removal-
by-objects or removal-by-indices scheme.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_PyCollection_Particles">
<code class="sig-name descname">remove_multi_by_PyCollection_Particles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pycollectionp</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_multi_by_PyCollection_Particles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_PyCollection_Particles" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection, which are themselves in common Python collections, such as
lists, dicts and numpy structures. In order to perform the removal, we can either directly remove the referred
Particle instances (for internally-ordered collections, e.g. ordered lists, sets, trees) or we may need to parse
each instance for its index (for random-access structures), which results in a considerable performance malus.</p>
<p>For collections where removal-by-object incurs a performance malus, it is advisable to multi-remove particles
by indices or IDs.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_indices">
<code class="sig-name descname">remove_multi_by_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_multi_by_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_multi_by_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection based on their indices. This works best for random-access
collections (e.g. numpy’s ndarrays, dense matrices and dense arrays), whereas internally ordered collections
shall rather use a removal-via-object-reference strategy.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_same">
<code class="sig-name descname">remove_same</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_class</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_same" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes particles from this collection that are themselves stored in another object of an equi-
structured ParticleCollection. As the structures of both collections are the same, a more efficient M-in-N
removal can be applied without an in-between reformatting.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_ID">
<code class="sig-name descname">remove_single_by_ID</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_single_by_ID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes a (particle) object from the collection based on the object’s ID. For some collections,
this operation may involve a parsing of the whole list and translation of the object’s ID into an index  or an
object reference in the collection in order to perform the removal - which results in a significant performance
malus.
In cases where a removal-by-ID would result in a performance malus, it is highly-advisable to use a different
removal functions, e.g. remove-by-object or remove-by-index.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_index">
<code class="sig-name descname">remove_single_by_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_single_by_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes a (particle) object from the collection based on its index within the collection. For
collections that are not based on random access (e.g. ordered lists, sets, trees), this function involves a
translation of the index into the specific object reference in the collection - or (if unavoidable) the
translation of the collection from a none-indexable, none-random-access structure into an indexable structure,
and then perform the removal.
In cases where a removal-by-index would result in a performance malus, it is highly-advisable to use a different
removal functions, e.g. remove-by-object or remove-by-ID.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_object">
<code class="sig-name descname">remove_single_by_object</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.remove_single_by_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.remove_single_by_object" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes a (particle) object from the collection based on its actual object. For collections that
are random-access and based on indices (e.g. unordered list, vectors, arrays and dense matrices), this function
would involves a parsing of the whole list and translation of the object into an index in the collection to
perform the removal - which results in a significant performance malus.
In cases where a removal-by-object would result in a performance malus, it is highly-advisable to use a different
removal functions, e.g. remove-by-index or remove-by-ID.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.set_variable_write_status">
<code class="sig-name descname">set_variable_write_status</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">write_status</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.set_variable_write_status"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.set_variable_write_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to set the write status of a Variable
:param var: Name of the variable (string)
:param status: Write status of the variable (True, False or ‘once’)</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.split" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits this collection into two disect equi-structured collections. The reason for it can, for
example, be that the set exceeds a pre-defined maximum number of elements, which for performance reasons
mandates a split.</p>
<p>On the other hand, this function can also internally split individual particles that are tagged byt status as
to be ‘split’ (see the particle status for information on that).</p>
<p>In order to distinguish both use cases, we can evaluate the ‘indices’ parameter. In cases where this is
‘None’, the split operation semantically refers to an internal split of individual particles - otherwise,
it performs a collection-split.</p>
<p>Comment: the function can be simplified later by pre-evaluating the function parameter and then reference
the individual, specific functions for element- or collection split.</p>
<p>The function shall return the newly created or extended Particle collection, i.e. either the collection that
results from a collection split or this very collection, containing the newly-split particles.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.toArray">
<code class="sig-name descname">toArray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.toArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.toArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This function converts (or: transforms; reformats; translates) this collection into an array-like structure
(e.g. Python list or numpy nD array) that can be addressed by index. In the common case of ‘no ID recovery’,
the global ID and the index match exactly.</p>
<p>While this function may be very convenient for may users, it is STRONGLY DISADVISED to use the function to
often, and the performance- and memory overhead malus may be exceed any speed-up one could get from optimised
data structures - in fact, for large collections with an implicit-order structure (i.e. ordered lists, sets,
trees, etc.), this may be ‘the most constly’ function in any kind of simulation.</p>
<p>It can be - though - useful at the final stage of a simulation to dump the results to disk.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.collectionsoa.ParticleCollectionSOA.toDictionary">
<code class="sig-name descname">toDictionary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pfile</span></em>, <em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">deleted_only</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/collectionsoa.html#ParticleCollectionSOA.toDictionary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.collectionsoa.ParticleCollectionSOA.toDictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all Particle data from one time step to a python dictionary.
:param pfile: ParticleFile object requesting the conversion
:param time: Time at which to write ParticleSet
:param deleted_only: Flag to write only the deleted Particles
returns two dictionaries: one for all variables to be written each outputdt,</p>
<blockquote>
<div><p>and one for all variables to be written once</p>
</div></blockquote>
<p>This function depends on the specific collection in question and thus needs to be specified in specific
derivative classes.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.particlesets.iterators">
<span id="parcels-particlesets-iterators-module"></span><h2>parcels.particlesets.iterators module<a class="headerlink" href="#module-parcels.particlesets.iterators" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.particlesets.iterators.BaseParticleAccessor">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.iterators.</code><code class="sig-name descname">BaseParticleAccessor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pcoll</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/iterators.html#BaseParticleAccessor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.iterators.BaseParticleAccessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Interface for the ParticleAccessor. Implements a wrapper around
particles to provide easy access.</p>
<dl class="py method">
<dt id="parcels.particlesets.iterators.BaseParticleAccessor.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/iterators.html#BaseParticleAccessor.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.iterators.BaseParticleAccessor.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal the underlying particle for deletion.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.iterators.BaseParticleAccessor.set_state">
<code class="sig-name descname">set_state</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/particlesets/iterators.html#BaseParticleAccessor.set_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.iterators.BaseParticleAccessor.set_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Syntactic sugar for changing the state of the underlying
particle.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="parcels.particlesets.iterators.BaseParticleCollectionIterator">
<em class="property">class </em><code class="sig-prename descclassname">parcels.particlesets.iterators.</code><code class="sig-name descname">BaseParticleCollectionIterator</code><a class="reference internal" href="_modules/parcels/particlesets/iterators.html#BaseParticleCollectionIterator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.particlesets.iterators.BaseParticleCollectionIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Interface for the ParticleCollection iterator. Provides the
ability to iterate over the particles in the ParticleCollection.</p>
<dl class="py method">
<dt id="parcels.particlesets.iterators.BaseParticleCollectionIterator.current">
<em class="property">property </em><code class="sig-name descname">current</code><a class="headerlink" href="#parcels.particlesets.iterators.BaseParticleCollectionIterator.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ParticleAccessor for the particle that the iteration
is currently at.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.iterators.BaseParticleCollectionIterator.head">
<em class="property">property </em><code class="sig-name descname">head</code><a class="headerlink" href="#parcels.particlesets.iterators.BaseParticleCollectionIterator.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ParticleAccessor for the first particle in the
ParticleSet.</p>
</dd></dl>

<dl class="py method">
<dt id="parcels.particlesets.iterators.BaseParticleCollectionIterator.tail">
<em class="property">property </em><code class="sig-name descname">tail</code><a class="headerlink" href="#parcels.particlesets.iterators.BaseParticleCollectionIterator.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ParticleAccessor for the last particle in the
ParticleSet.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parcels.tools.statuscodes">
<span id="parcels-tools-statuscodes-module"></span><h2>parcels.tools.statuscodes module<a class="headerlink" href="#module-parcels.tools.statuscodes" title="Permalink to this headline">¶</a></h2>
<p>Collection of pre-built recovery kernels</p>
<dl class="py exception">
<dt id="parcels.tools.statuscodes.FieldOutOfBoundError">
<em class="property">exception </em><code class="sig-prename descclassname">parcels.tools.statuscodes.</code><code class="sig-name descname">FieldOutOfBoundError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">field</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/statuscodes.html#FieldOutOfBoundError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.statuscodes.FieldOutOfBoundError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeError</span></code></p>
<p>Utility error class to propagate out-of-bound field sampling in Scipy mode</p>
</dd></dl>

<dl class="py exception">
<dt id="parcels.tools.statuscodes.FieldSamplingError">
<em class="property">exception </em><code class="sig-prename descclassname">parcels.tools.statuscodes.</code><code class="sig-name descname">FieldSamplingError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">field</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/statuscodes.html#FieldSamplingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.statuscodes.FieldSamplingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeError</span></code></p>
<p>Utility error class to propagate erroneous field sampling in Scipy mode</p>
</dd></dl>

<dl class="py exception">
<dt id="parcels.tools.statuscodes.KernelError">
<em class="property">exception </em><code class="sig-prename descclassname">parcels.tools.statuscodes.</code><code class="sig-name descname">KernelError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/statuscodes.html#KernelError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.statuscodes.KernelError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeError</span></code></p>
<p>General particle kernel error with optional custom message</p>
</dd></dl>

<dl class="py exception">
<dt id="parcels.tools.statuscodes.OutOfBoundsError">
<em class="property">exception </em><code class="sig-prename descclassname">parcels.tools.statuscodes.</code><code class="sig-name descname">OutOfBoundsError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lon</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/statuscodes.html#OutOfBoundsError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.statuscodes.OutOfBoundsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.tools.statuscodes.KernelError" title="parcels.tools.statuscodes.KernelError"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.tools.statuscodes.KernelError</span></code></a></p>
<p>Particle kernel error for out-of-bounds field sampling</p>
</dd></dl>

<dl class="py exception">
<dt id="parcels.tools.statuscodes.OutOfTimeError">
<em class="property">exception </em><code class="sig-prename descclassname">parcels.tools.statuscodes.</code><code class="sig-name descname">OutOfTimeError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/statuscodes.html#OutOfTimeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.statuscodes.OutOfTimeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.tools.statuscodes.KernelError" title="parcels.tools.statuscodes.KernelError"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.tools.statuscodes.KernelError</span></code></a></p>
<p>Particle kernel error for time extrapolation field sampling</p>
</dd></dl>

<dl class="py exception">
<dt id="parcels.tools.statuscodes.ThroughSurfaceError">
<em class="property">exception </em><code class="sig-prename descclassname">parcels.tools.statuscodes.</code><code class="sig-name descname">ThroughSurfaceError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particle</span></em>, <em class="sig-param"><span class="n">fieldset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lon</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/statuscodes.html#ThroughSurfaceError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.statuscodes.ThroughSurfaceError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.tools.statuscodes.KernelError" title="parcels.tools.statuscodes.KernelError"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.tools.statuscodes.KernelError</span></code></a></p>
<p>Particle kernel error for field sampling at surface</p>
</dd></dl>

<dl class="py exception">
<dt id="parcels.tools.statuscodes.TimeExtrapolationError">
<em class="property">exception </em><code class="sig-prename descclassname">parcels.tools.statuscodes.</code><code class="sig-name descname">TimeExtrapolationError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">field</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">'allow_time_extrapoltion'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/statuscodes.html#TimeExtrapolationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.statuscodes.TimeExtrapolationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeError</span></code></p>
<p>Utility error class to propagate erroneous time extrapolation sampling in Scipy mode</p>
</dd></dl>

</div>
<div class="section" id="module-parcels.tools.converters">
<span id="parcels-tools-converters-module"></span><h2>parcels.tools.converters module<a class="headerlink" href="#module-parcels.tools.converters" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="parcels.tools.converters.Geographic">
<em class="property">class </em><code class="sig-prename descclassname">parcels.tools.converters.</code><code class="sig-name descname">Geographic</code><a class="reference internal" href="_modules/parcels/tools/converters.html#Geographic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.Geographic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.tools.converters.UnitConverter" title="parcels.tools.converters.UnitConverter"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.tools.converters.UnitConverter</span></code></a></p>
<p>Unit converter from geometric to geographic coordinates (m to degree)</p>
</dd></dl>

<dl class="py class">
<dt id="parcels.tools.converters.GeographicPolar">
<em class="property">class </em><code class="sig-prename descclassname">parcels.tools.converters.</code><code class="sig-name descname">GeographicPolar</code><a class="reference internal" href="_modules/parcels/tools/converters.html#GeographicPolar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.GeographicPolar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.tools.converters.UnitConverter" title="parcels.tools.converters.UnitConverter"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.tools.converters.UnitConverter</span></code></a></p>
<p>Unit converter from geometric to geographic coordinates (m to degree)
with a correction to account for narrower grid cells closer to the poles.</p>
</dd></dl>

<dl class="py class">
<dt id="parcels.tools.converters.GeographicPolarSquare">
<em class="property">class </em><code class="sig-prename descclassname">parcels.tools.converters.</code><code class="sig-name descname">GeographicPolarSquare</code><a class="reference internal" href="_modules/parcels/tools/converters.html#GeographicPolarSquare"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.GeographicPolarSquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.tools.converters.UnitConverter" title="parcels.tools.converters.UnitConverter"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.tools.converters.UnitConverter</span></code></a></p>
<p>Square distance converter from geometric to geographic coordinates (m2 to degree2)
with a correction to account for narrower grid cells closer to the poles.</p>
</dd></dl>

<dl class="py class">
<dt id="parcels.tools.converters.GeographicSquare">
<em class="property">class </em><code class="sig-prename descclassname">parcels.tools.converters.</code><code class="sig-name descname">GeographicSquare</code><a class="reference internal" href="_modules/parcels/tools/converters.html#GeographicSquare"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.GeographicSquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parcels.tools.converters.UnitConverter" title="parcels.tools.converters.UnitConverter"><code class="xref py py-class docutils literal notranslate"><span class="pre">parcels.tools.converters.UnitConverter</span></code></a></p>
<p>Square distance converter from geometric to geographic coordinates (m2 to degree2)</p>
</dd></dl>

<dl class="py class">
<dt id="parcels.tools.converters.TimeConverter">
<em class="property">class </em><code class="sig-prename descclassname">parcels.tools.converters.</code><code class="sig-name descname">TimeConverter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time_origin</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/converters.html#TimeConverter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.TimeConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Converter class for dates with different calendars in FieldSets</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>time_origin: time origin of the class. Currently supported formats are
float, integer, numpy.datetime64, and netcdftime.DatetimeNoLeap</p>
</dd>
</dl>
<dl class="py method">
<dt id="parcels.tools.converters.TimeConverter.fulltime">
<code class="sig-name descname">fulltime</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/converters.html#TimeConverter.fulltime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.TimeConverter.fulltime" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to convert a time difference in seconds to a date, based on the time_origin</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>time: input time</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>self.time_origin + time</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="parcels.tools.converters.TimeConverter.reltime">
<code class="sig-name descname">reltime</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/converters.html#TimeConverter.reltime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.TimeConverter.reltime" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to compute the difference, in seconds, between a time and the time_origin
of the TimeConverter</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>time: input time</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>time - self.time_origin</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="parcels.tools.converters.UnitConverter">
<em class="property">class </em><code class="sig-prename descclassname">parcels.tools.converters.</code><code class="sig-name descname">UnitConverter</code><a class="reference internal" href="_modules/parcels/tools/converters.html#UnitConverter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.UnitConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interface class for spatial unit conversion during field sampling
that performs no conversion.</p>
</dd></dl>

<dl class="py function">
<dt id="parcels.tools.converters.convert_xarray_time_units">
<code class="sig-prename descclassname">parcels.tools.converters.</code><code class="sig-name descname">convert_xarray_time_units</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ds</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/tools/converters.html#convert_xarray_time_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.tools.converters.convert_xarray_time_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Fixes DataArrays that have time.Unit instead of expected time.units</p>
</dd></dl>

</div>
<div class="section" id="module-parcels.tools.loggers">
<span id="parcels-tools-loggers-module"></span><h2>parcels.tools.loggers module<a class="headerlink" href="#module-parcels.tools.loggers" title="Permalink to this headline">¶</a></h2>
<p>Script to create a <cite>logger</cite> for Parcels</p>
</div>
<div class="section" id="module-parcels.plotting">
<span id="parcels-plotting-module"></span><h2>parcels.plotting module<a class="headerlink" href="#module-parcels.plotting" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="parcels.plotting.cartopy_colorbar">
<code class="sig-prename descclassname">parcels.plotting.</code><code class="sig-name descname">cartopy_colorbar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cs</span></em>, <em class="sig-param"><span class="n">plt</span></em>, <em class="sig-param"><span class="n">fig</span></em>, <em class="sig-param"><span class="n">ax</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/plotting.html#cartopy_colorbar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.plotting.cartopy_colorbar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="parcels.plotting.create_parcelsfig_axis">
<code class="sig-prename descclassname">parcels.plotting.</code><code class="sig-name descname">create_parcelsfig_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spherical</span></em>, <em class="sig-param"><span class="n">land</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">central_longitude</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cartopy_features</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/plotting.html#create_parcelsfig_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.plotting.create_parcelsfig_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="parcels.plotting.parsedomain">
<code class="sig-prename descclassname">parcels.plotting.</code><code class="sig-name descname">parsedomain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">domain</span></em>, <em class="sig-param"><span class="n">field</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/plotting.html#parsedomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.plotting.parsedomain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="parcels.plotting.parsetimestr">
<code class="sig-prename descclassname">parcels.plotting.</code><code class="sig-name descname">parsetimestr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time_origin</span></em>, <em class="sig-param"><span class="n">show_time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/plotting.html#parsetimestr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.plotting.parsetimestr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="parcels.plotting.plotfield">
<code class="sig-prename descclassname">parcels.plotting.</code><code class="sig-name descname">plotfield</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">field</span></em>, <em class="sig-param"><span class="n">show_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">depth_level</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">land</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">savefile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/plotting.html#plotfield"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.plotting.plotfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to plot a Parcels Field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>show_time</strong> – Time at which to show the Field</p></li>
<li><p><strong>domain</strong> – dictionary (with keys ‘N’, ‘S’, ‘E’, ‘W’) defining domain to show</p></li>
<li><p><strong>depth_level</strong> – depth level to be plotted (default 0)</p></li>
<li><p><strong>projection</strong> – type of cartopy projection to use (default PlateCarree)</p></li>
<li><p><strong>land</strong> – Boolean whether to show land. This is ignored for flat meshes</p></li>
<li><p><strong>vmin</strong> – minimum colour scale (only in single-plot mode)</p></li>
<li><p><strong>vmax</strong> – maximum colour scale (only in single-plot mode)</p></li>
<li><p><strong>savefile</strong> – Name of a file to save the plot to</p></li>
<li><p><strong>animation</strong> – Boolean whether result is a single plot, or an animation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="parcels.plotting.plotparticles">
<code class="sig-prename descclassname">parcels.plotting.</code><code class="sig-name descname">plotparticles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particles</span></em>, <em class="sig-param"><span class="n">with_particles</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">show_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">field</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">projection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">land</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">vmin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vmax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">savefile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">animation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/parcels/plotting.html#plotparticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parcels.plotting.plotparticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to plot a Parcels ParticleSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>show_time</strong> – Time at which to show the ParticleSet</p></li>
<li><p><strong>with_particles</strong> – Boolean whether particles are also plotted on Field</p></li>
<li><p><strong>field</strong> – Field to plot under particles (either None, a Field object, or ‘vector’)</p></li>
<li><p><strong>domain</strong> – dictionary (with keys ‘N’, ‘S’, ‘E’, ‘W’) defining domain to show</p></li>
<li><p><strong>projection</strong> – type of cartopy projection to use (default PlateCarree)</p></li>
<li><p><strong>land</strong> – Boolean whether to show land. This is ignored for flat meshes</p></li>
<li><p><strong>vmin</strong> – minimum colour scale (only in single-plot mode)</p></li>
<li><p><strong>vmax</strong> – maximum colour scale (only in single-plot mode)</p></li>
<li><p><strong>savefile</strong> – Name of a file to save the plot to</p></li>
<li><p><strong>animation</strong> – Boolean whether result is a single plot, or an animation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-scripts.plottrajectoriesfile">
<span id="scripts-plottrajectoriesfile-module"></span><h2>scripts.plottrajectoriesfile module<a class="headerlink" href="#module-scripts.plottrajectoriesfile" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="scripts.plottrajectoriesfile.plotTrajectoriesFile">
<code class="sig-prename descclassname">scripts.plottrajectoriesfile.</code><code class="sig-name descname">plotTrajectoriesFile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'2d'</span></em>, <em class="sig-param"><span class="n">tracerfile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tracerfield</span><span class="o">=</span><span class="default_value">'P'</span></em>, <em class="sig-param"><span class="n">tracerlon</span><span class="o">=</span><span class="default_value">'x'</span></em>, <em class="sig-param"><span class="n">tracerlat</span><span class="o">=</span><span class="default_value">'y'</span></em>, <em class="sig-param"><span class="n">recordedvar</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">movie_forward</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">bins</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">show_plt</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">central_longitude</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scripts/plottrajectoriesfile.html#plotTrajectoriesFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scripts.plottrajectoriesfile.plotTrajectoriesFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Quick and simple plotting of Parcels trajectories</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – Name of Parcels-generated NetCDF file with particle positions</p></li>
<li><p><strong>mode</strong> – Type of plot to show. Supported are ‘2d’, ‘3d’, ‘hist2d’,
‘movie2d’ and ‘movie2d_notebook’. The latter two give animations,
with ‘movie2d_notebook’ specifically designed for jupyter notebooks</p></li>
<li><p><strong>tracerfile</strong> – Name of NetCDF file to show as background</p></li>
<li><p><strong>tracerfield</strong> – Name of variable to show as background</p></li>
<li><p><strong>tracerlon</strong> – Name of longitude dimension of variable to show as background</p></li>
<li><p><strong>tracerlat</strong> – Name of latitude dimension of variable to show as background</p></li>
<li><p><strong>recordedvar</strong> – Name of variable used to color particles in scatter-plot.
Only works in ‘movie2d’ or ‘movie2d_notebook’ mode.</p></li>
<li><p><strong>movie_forward</strong> – Boolean whether to show movie in forward or backward mode (default True)</p></li>
<li><p><strong>bins</strong> – Number of bins to use in <cite>hist2d</cite> mode. See also <a class="reference external" href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist2d.html">https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist2d.html</a></p></li>
<li><p><strong>show_plt</strong> – Boolean whether plot should directly be show (for py.test)</p></li>
<li><p><strong>central_longitude</strong> – Degrees East at which to center the plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-scripts.get_examples">
<span id="scripts-get-examples-module"></span><h2>scripts.get_examples module<a class="headerlink" href="#module-scripts.get_examples" title="Permalink to this headline">¶</a></h2>
<p>Get example scripts, notebooks, and data files.</p>
<dl class="py function">
<dt id="scripts.get_examples.copy_data_and_examples_from_package_to">
<code class="sig-prename descclassname">scripts.get_examples.</code><code class="sig-name descname">copy_data_and_examples_from_package_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target_path</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scripts/get_examples.html#copy_data_and_examples_from_package_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scripts.get_examples.copy_data_and_examples_from_package_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy example data from Parcels directory.</p>
<p>Return thos parths of the list <cite>file_names</cite> that were not found in the
package.</p>
</dd></dl>

<dl class="py function">
<dt id="scripts.get_examples.download_files">
<code class="sig-prename descclassname">scripts.get_examples.</code><code class="sig-name descname">download_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source_url</span></em>, <em class="sig-param"><span class="n">file_names</span></em>, <em class="sig-param"><span class="n">target_path</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scripts/get_examples.html#download_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scripts.get_examples.download_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirror file_names from source_url to target_path.</p>
</dd></dl>

<dl class="py function">
<dt id="scripts.get_examples.main">
<code class="sig-prename descclassname">scripts.get_examples.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target_path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/scripts/get_examples.html#main"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scripts.get_examples.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Get example scripts, example notebooks, and example data.</p>
<p>Copy the examples from the package directory and get the example data either
from the package directory or from the Parcels website.</p>
</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="#">
              <img class="logo" src="_static/parcelslogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Parcels documentation</a><ul>
<li><a class="reference internal" href="#module-parcels.particlesets.particlesetsoa">parcels.particleset module</a></li>
<li><a class="reference internal" href="#module-parcels.fieldset">parcels.fieldset module</a></li>
<li><a class="reference internal" href="#module-parcels.field">parcels.field module</a></li>
<li><a class="reference internal" href="#module-parcels.gridset">parcels.gridset module</a></li>
<li><a class="reference internal" href="#module-parcels.grid">parcels.grid module</a></li>
<li><a class="reference internal" href="#module-parcels.particle">parcels.particle module</a></li>
<li><a class="reference internal" href="#module-parcels.kernels.advection">parcels.kernels.advection module</a></li>
<li><a class="reference internal" href="#module-parcels.kernels.advectiondiffusion">parcels.kernels.advectiondiffusion module</a></li>
<li><a class="reference internal" href="#module-parcels.kernels.EOSseawaterproperties">parcels.kernels.EOSseawaterproperties module</a></li>
<li><a class="reference internal" href="#module-parcels.kernels.TEOSseawaterdensity">parcels.kernels.TEOSseawaterdensity module</a></li>
<li><a class="reference internal" href="#module-parcels.codegenerator">parcels.compilation.codegenerator module</a></li>
<li><a class="reference internal" href="#parcels-compilation-compiler-module">parcels.compilation.compiler module</a></li>
<li><a class="reference internal" href="#module-parcels.kernel">parcels.kernel module</a></li>
<li><a class="reference internal" href="#module-parcels.particlefile">parcels.particlefile module</a></li>
<li><a class="reference internal" href="#module-parcels.rng">parcels.rng module</a></li>
<li><a class="reference internal" href="#module-parcels.particlesets.baseparticleset">parcels.particlesets.baseparticleset module</a></li>
<li><a class="reference internal" href="#module-parcels.particlesets.collections">parcels.particlesets.collections module</a></li>
<li><a class="reference internal" href="#module-parcels.particlesets.collectionsoa">parcels.particlesets.collectionsoa module</a></li>
<li><a class="reference internal" href="#module-parcels.particlesets.iterators">parcels.particlesets.iterators module</a></li>
<li><a class="reference internal" href="#module-parcels.tools.statuscodes">parcels.tools.statuscodes module</a></li>
<li><a class="reference internal" href="#module-parcels.tools.converters">parcels.tools.converters module</a></li>
<li><a class="reference internal" href="#module-parcels.tools.loggers">parcels.tools.loggers module</a></li>
<li><a class="reference internal" href="#module-parcels.plotting">parcels.plotting module</a></li>
<li><a class="reference internal" href="#module-scripts.plottrajectoriesfile">scripts.plottrajectoriesfile module</a></li>
<li><a class="reference internal" href="#module-scripts.get_examples">scripts.get_examples module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Parcels 2.2.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Parcels documentation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Michael Lange and Erik van Sebille.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>